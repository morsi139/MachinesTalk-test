{"ast":null,"code":"import { Trie } from '@wry/trie';\nexport { Trie as KeyTrie } from '@wry/trie';\nimport { Slot } from '@wry/context';\nexport { asyncFromGen, bind as bindContext, noContext, setTimeout } from '@wry/context';\n\nfunction defaultDispose() {}\n\nvar Cache =\n/** @class */\nfunction () {\n  function Cache(max, dispose) {\n    if (max === void 0) {\n      max = Infinity;\n    }\n\n    if (dispose === void 0) {\n      dispose = defaultDispose;\n    }\n\n    this.max = max;\n    this.dispose = dispose;\n    this.map = new Map();\n    this.newest = null;\n    this.oldest = null;\n  }\n\n  Cache.prototype.has = function (key) {\n    return this.map.has(key);\n  };\n\n  Cache.prototype.get = function (key) {\n    var node = this.getNode(key);\n    return node && node.value;\n  };\n\n  Cache.prototype.getNode = function (key) {\n    var node = this.map.get(key);\n\n    if (node && node !== this.newest) {\n      var older = node.older,\n          newer = node.newer;\n\n      if (newer) {\n        newer.older = older;\n      }\n\n      if (older) {\n        older.newer = newer;\n      }\n\n      node.older = this.newest;\n      node.older.newer = node;\n      node.newer = null;\n      this.newest = node;\n\n      if (node === this.oldest) {\n        this.oldest = newer;\n      }\n    }\n\n    return node;\n  };\n\n  Cache.prototype.set = function (key, value) {\n    var node = this.getNode(key);\n\n    if (node) {\n      return node.value = value;\n    }\n\n    node = {\n      key: key,\n      value: value,\n      newer: null,\n      older: this.newest\n    };\n\n    if (this.newest) {\n      this.newest.newer = node;\n    }\n\n    this.newest = node;\n    this.oldest = this.oldest || node;\n    this.map.set(key, node);\n    return node.value;\n  };\n\n  Cache.prototype.clean = function () {\n    while (this.oldest && this.map.size > this.max) {\n      this.delete(this.oldest.key);\n    }\n  };\n\n  Cache.prototype.delete = function (key) {\n    var node = this.map.get(key);\n\n    if (node) {\n      if (node === this.newest) {\n        this.newest = node.older;\n      }\n\n      if (node === this.oldest) {\n        this.oldest = node.newer;\n      }\n\n      if (node.newer) {\n        node.newer.older = node.older;\n      }\n\n      if (node.older) {\n        node.older.newer = node.newer;\n      }\n\n      this.map.delete(key);\n      this.dispose(node.value, key);\n      return true;\n    }\n\n    return false;\n  };\n\n  return Cache;\n}();\n\nvar parentEntrySlot = new Slot();\n\nvar _a;\n\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\nvar // This Array.from polyfill is restricted to working with Set<any> for now,\n// but we can improve the polyfill and add other input types, as needed. Note\n// that this fallback implementation will only be used if the host environment\n// does not support a native Array.from function. In most modern JS runtimes,\n// the toArray function exported here will be === Array.from.\ntoArray = (_a = Array.from, _a === void 0 ? function (collection) {\n  var array = [];\n  collection.forEach(function (item) {\n    return array.push(item);\n  });\n  return array;\n} : _a);\n\nfunction maybeUnsubscribe(entryOrDep) {\n  var unsubscribe = entryOrDep.unsubscribe;\n\n  if (typeof unsubscribe === \"function\") {\n    entryOrDep.unsubscribe = void 0;\n    unsubscribe();\n  }\n}\n\nvar emptySetPool = [];\nvar POOL_TARGET_SIZE = 100; // Since this package might be used browsers, we should avoid using the\n// Node built-in assert module.\n\nfunction assert(condition, optionalMessage) {\n  if (!condition) {\n    throw new Error(optionalMessage || \"assertion failure\");\n  }\n}\n\nfunction valueIs(a, b) {\n  var len = a.length;\n  return (// Unknown values are not equal to each other.\n    len > 0 && // Both values must be ordinary (or both exceptional) to be equal.\n    len === b.length && // The underlying value or exception must be the same.\n    a[len - 1] === b[len - 1]\n  );\n}\n\nfunction valueGet(value) {\n  switch (value.length) {\n    case 0:\n      throw new Error(\"unknown value\");\n\n    case 1:\n      return value[0];\n\n    case 2:\n      throw value[1];\n  }\n}\n\nfunction valueCopy(value) {\n  return value.slice(0);\n}\n\nvar Entry =\n/** @class */\nfunction () {\n  function Entry(fn) {\n    this.fn = fn;\n    this.parents = new Set();\n    this.childValues = new Map(); // When this Entry has children that are dirty, this property becomes\n    // a Set containing other Entry objects, borrowed from emptySetPool.\n    // When the set becomes empty, it gets recycled back to emptySetPool.\n\n    this.dirtyChildren = null;\n    this.dirty = true;\n    this.recomputing = false;\n    this.value = [];\n    this.deps = null;\n    ++Entry.count;\n  }\n\n  Entry.prototype.peek = function () {\n    if (this.value.length === 1 && !mightBeDirty(this)) {\n      rememberParent(this);\n      return this.value[0];\n    }\n  }; // This is the most important method of the Entry API, because it\n  // determines whether the cached this.value can be returned immediately,\n  // or must be recomputed. The overall performance of the caching system\n  // depends on the truth of the following observations: (1) this.dirty is\n  // usually false, (2) this.dirtyChildren is usually null/empty, and thus\n  // (3) valueGet(this.value) is usually returned without recomputation.\n\n\n  Entry.prototype.recompute = function (args) {\n    assert(!this.recomputing, \"already recomputing\");\n    rememberParent(this);\n    return mightBeDirty(this) ? reallyRecompute(this, args) : valueGet(this.value);\n  };\n\n  Entry.prototype.setDirty = function () {\n    if (this.dirty) return;\n    this.dirty = true;\n    this.value.length = 0;\n    reportDirty(this); // We can go ahead and unsubscribe here, since any further dirty\n    // notifications we receive will be redundant, and unsubscribing may\n    // free up some resources, e.g. file watchers.\n\n    maybeUnsubscribe(this);\n  };\n\n  Entry.prototype.dispose = function () {\n    var _this = this;\n\n    this.setDirty(); // Sever any dependency relationships with our own children, so those\n    // children don't retain this parent Entry in their child.parents sets,\n    // thereby preventing it from being fully garbage collected.\n\n    forgetChildren(this); // Because this entry has been kicked out of the cache (in index.js),\n    // we've lost the ability to find out if/when this entry becomes dirty,\n    // whether that happens through a subscription, because of a direct call\n    // to entry.setDirty(), or because one of its children becomes dirty.\n    // Because of this loss of future information, we have to assume the\n    // worst (that this entry might have become dirty very soon), so we must\n    // immediately mark this entry's parents as dirty. Normally we could\n    // just call entry.setDirty() rather than calling parent.setDirty() for\n    // each parent, but that would leave this entry in parent.childValues\n    // and parent.dirtyChildren, which would prevent the child from being\n    // truly forgotten.\n\n    eachParent(this, function (parent, child) {\n      parent.setDirty();\n      forgetChild(parent, _this);\n    });\n  };\n\n  Entry.prototype.forget = function () {\n    // The code that creates Entry objects in index.ts will replace this method\n    // with one that actually removes the Entry from the cache, which will also\n    // trigger the entry.dispose method.\n    this.dispose();\n  };\n\n  Entry.prototype.dependOn = function (dep) {\n    dep.add(this);\n\n    if (!this.deps) {\n      this.deps = emptySetPool.pop() || new Set();\n    }\n\n    this.deps.add(dep);\n  };\n\n  Entry.prototype.forgetDeps = function () {\n    var _this = this;\n\n    if (this.deps) {\n      toArray(this.deps).forEach(function (dep) {\n        return dep.delete(_this);\n      });\n      this.deps.clear();\n      emptySetPool.push(this.deps);\n      this.deps = null;\n    }\n  };\n\n  Entry.count = 0;\n  return Entry;\n}();\n\nfunction rememberParent(child) {\n  var parent = parentEntrySlot.getValue();\n\n  if (parent) {\n    child.parents.add(parent);\n\n    if (!parent.childValues.has(child)) {\n      parent.childValues.set(child, []);\n    }\n\n    if (mightBeDirty(child)) {\n      reportDirtyChild(parent, child);\n    } else {\n      reportCleanChild(parent, child);\n    }\n\n    return parent;\n  }\n}\n\nfunction reallyRecompute(entry, args) {\n  forgetChildren(entry); // Set entry as the parent entry while calling recomputeNewValue(entry).\n\n  parentEntrySlot.withValue(entry, recomputeNewValue, [entry, args]);\n\n  if (maybeSubscribe(entry, args)) {\n    // If we successfully recomputed entry.value and did not fail to\n    // (re)subscribe, then this Entry is no longer explicitly dirty.\n    setClean(entry);\n  }\n\n  return valueGet(entry.value);\n}\n\nfunction recomputeNewValue(entry, args) {\n  entry.recomputing = true; // Set entry.value as unknown.\n\n  entry.value.length = 0;\n\n  try {\n    // If entry.fn succeeds, entry.value will become a normal Value.\n    entry.value[0] = entry.fn.apply(null, args);\n  } catch (e) {\n    // If entry.fn throws, entry.value will become exceptional.\n    entry.value[1] = e;\n  } // Either way, this line is always reached.\n\n\n  entry.recomputing = false;\n}\n\nfunction mightBeDirty(entry) {\n  return entry.dirty || !!(entry.dirtyChildren && entry.dirtyChildren.size);\n}\n\nfunction setClean(entry) {\n  entry.dirty = false;\n\n  if (mightBeDirty(entry)) {\n    // This Entry may still have dirty children, in which case we can't\n    // let our parents know we're clean just yet.\n    return;\n  }\n\n  reportClean(entry);\n}\n\nfunction reportDirty(child) {\n  eachParent(child, reportDirtyChild);\n}\n\nfunction reportClean(child) {\n  eachParent(child, reportCleanChild);\n}\n\nfunction eachParent(child, callback) {\n  var parentCount = child.parents.size;\n\n  if (parentCount) {\n    var parents = toArray(child.parents);\n\n    for (var i = 0; i < parentCount; ++i) {\n      callback(parents[i], child);\n    }\n  }\n} // Let a parent Entry know that one of its children may be dirty.\n\n\nfunction reportDirtyChild(parent, child) {\n  // Must have called rememberParent(child) before calling\n  // reportDirtyChild(parent, child).\n  assert(parent.childValues.has(child));\n  assert(mightBeDirty(child));\n  var parentWasClean = !mightBeDirty(parent);\n\n  if (!parent.dirtyChildren) {\n    parent.dirtyChildren = emptySetPool.pop() || new Set();\n  } else if (parent.dirtyChildren.has(child)) {\n    // If we already know this child is dirty, then we must have already\n    // informed our own parents that we are dirty, so we can terminate\n    // the recursion early.\n    return;\n  }\n\n  parent.dirtyChildren.add(child); // If parent was clean before, it just became (possibly) dirty (according to\n  // mightBeDirty), since we just added child to parent.dirtyChildren.\n\n  if (parentWasClean) {\n    reportDirty(parent);\n  }\n} // Let a parent Entry know that one of its children is no longer dirty.\n\n\nfunction reportCleanChild(parent, child) {\n  // Must have called rememberChild(child) before calling\n  // reportCleanChild(parent, child).\n  assert(parent.childValues.has(child));\n  assert(!mightBeDirty(child));\n  var childValue = parent.childValues.get(child);\n\n  if (childValue.length === 0) {\n    parent.childValues.set(child, valueCopy(child.value));\n  } else if (!valueIs(childValue, child.value)) {\n    parent.setDirty();\n  }\n\n  removeDirtyChild(parent, child);\n\n  if (mightBeDirty(parent)) {\n    return;\n  }\n\n  reportClean(parent);\n}\n\nfunction removeDirtyChild(parent, child) {\n  var dc = parent.dirtyChildren;\n\n  if (dc) {\n    dc.delete(child);\n\n    if (dc.size === 0) {\n      if (emptySetPool.length < POOL_TARGET_SIZE) {\n        emptySetPool.push(dc);\n      }\n\n      parent.dirtyChildren = null;\n    }\n  }\n} // Removes all children from this entry and returns an array of the\n// removed children.\n\n\nfunction forgetChildren(parent) {\n  if (parent.childValues.size > 0) {\n    parent.childValues.forEach(function (_value, child) {\n      forgetChild(parent, child);\n    });\n  } // Remove this parent Entry from any sets to which it was added by the\n  // addToSet method.\n\n\n  parent.forgetDeps(); // After we forget all our children, this.dirtyChildren must be empty\n  // and therefore must have been reset to null.\n\n  assert(parent.dirtyChildren === null);\n}\n\nfunction forgetChild(parent, child) {\n  child.parents.delete(parent);\n  parent.childValues.delete(child);\n  removeDirtyChild(parent, child);\n}\n\nfunction maybeSubscribe(entry, args) {\n  if (typeof entry.subscribe === \"function\") {\n    try {\n      maybeUnsubscribe(entry); // Prevent double subscriptions.\n\n      entry.unsubscribe = entry.subscribe.apply(null, args);\n    } catch (e) {\n      // If this Entry has a subscribe function and it threw an exception\n      // (or an unsubscribe function it previously returned now throws),\n      // return false to indicate that we were not able to subscribe (or\n      // unsubscribe), and this Entry should remain dirty.\n      entry.setDirty();\n      return false;\n    }\n  } // Returning true indicates either that there was no entry.subscribe\n  // function or that it succeeded.\n\n\n  return true;\n}\n\nvar EntryMethods = {\n  setDirty: true,\n  dispose: true,\n  forget: true // Fully remove parent Entry from LRU cache and computation graph\n\n};\n\nfunction dep(options) {\n  var depsByKey = new Map();\n  var subscribe = options && options.subscribe;\n\n  function depend(key) {\n    var parent = parentEntrySlot.getValue();\n\n    if (parent) {\n      var dep_1 = depsByKey.get(key);\n\n      if (!dep_1) {\n        depsByKey.set(key, dep_1 = new Set());\n      }\n\n      parent.dependOn(dep_1);\n\n      if (typeof subscribe === \"function\") {\n        maybeUnsubscribe(dep_1);\n        dep_1.unsubscribe = subscribe(key);\n      }\n    }\n  }\n\n  depend.dirty = function dirty(key, entryMethodName) {\n    var dep = depsByKey.get(key);\n\n    if (dep) {\n      var m_1 = entryMethodName && hasOwnProperty.call(EntryMethods, entryMethodName) ? entryMethodName : \"setDirty\"; // We have to use toArray(dep).forEach instead of dep.forEach, because\n      // modifying a Set while iterating over it can cause elements in the Set\n      // to be removed from the Set before they've been iterated over.\n\n      toArray(dep).forEach(function (entry) {\n        return entry[m_1]();\n      });\n      depsByKey.delete(key);\n      maybeUnsubscribe(dep);\n    }\n  };\n\n  return depend;\n}\n\nfunction makeDefaultMakeCacheKeyFunction() {\n  var keyTrie = new Trie(typeof WeakMap === \"function\");\n  return function () {\n    return keyTrie.lookupArray(arguments);\n  };\n} // The defaultMakeCacheKey function is remarkably powerful, because it gives\n// a unique object for any shallow-identical list of arguments. If you need\n// to implement a custom makeCacheKey function, you may find it helpful to\n// delegate the final work to defaultMakeCacheKey, which is why we export it\n// here. However, you may want to avoid defaultMakeCacheKey if your runtime\n// does not support WeakMap, or you have the ability to return a string key.\n// In those cases, just write your own custom makeCacheKey functions.\n\n\nvar defaultMakeCacheKey = makeDefaultMakeCacheKeyFunction();\nvar caches = new Set();\n\nfunction wrap(originalFunction, options) {\n  if (options === void 0) {\n    options = Object.create(null);\n  }\n\n  var cache = new Cache(options.max || Math.pow(2, 16), function (entry) {\n    return entry.dispose();\n  });\n  var keyArgs = options.keyArgs;\n  var makeCacheKey = options.makeCacheKey || makeDefaultMakeCacheKeyFunction();\n\n  var optimistic = function () {\n    var key = makeCacheKey.apply(null, keyArgs ? keyArgs.apply(null, arguments) : arguments);\n\n    if (key === void 0) {\n      return originalFunction.apply(null, arguments);\n    }\n\n    var entry = cache.get(key);\n\n    if (!entry) {\n      cache.set(key, entry = new Entry(originalFunction));\n      entry.subscribe = options.subscribe; // Give the Entry the ability to trigger cache.delete(key), even though\n      // the Entry itself does not know about key or cache.\n\n      entry.forget = function () {\n        return cache.delete(key);\n      };\n    }\n\n    var value = entry.recompute(Array.prototype.slice.call(arguments)); // Move this entry to the front of the least-recently used queue,\n    // since we just finished computing its value.\n\n    cache.set(key, entry);\n    caches.add(cache); // Clean up any excess entries in the cache, but only if there is no\n    // active parent entry, meaning we're not in the middle of a larger\n    // computation that might be flummoxed by the cleaning.\n\n    if (!parentEntrySlot.hasValue()) {\n      caches.forEach(function (cache) {\n        return cache.clean();\n      });\n      caches.clear();\n    }\n\n    return value;\n  };\n\n  Object.defineProperty(optimistic, \"size\", {\n    get: function () {\n      return cache[\"map\"].size;\n    },\n    configurable: false,\n    enumerable: false\n  });\n\n  function dirtyKey(key) {\n    var entry = cache.get(key);\n\n    if (entry) {\n      entry.setDirty();\n    }\n  }\n\n  optimistic.dirtyKey = dirtyKey;\n\n  optimistic.dirty = function dirty() {\n    dirtyKey(makeCacheKey.apply(null, arguments));\n  };\n\n  function peekKey(key) {\n    var entry = cache.get(key);\n\n    if (entry) {\n      return entry.peek();\n    }\n  }\n\n  optimistic.peekKey = peekKey;\n\n  optimistic.peek = function peek() {\n    return peekKey(makeCacheKey.apply(null, arguments));\n  };\n\n  function forgetKey(key) {\n    return cache.delete(key);\n  }\n\n  optimistic.forgetKey = forgetKey;\n\n  optimistic.forget = function forget() {\n    return forgetKey(makeCacheKey.apply(null, arguments));\n  };\n\n  optimistic.makeCacheKey = makeCacheKey;\n  optimistic.getKey = keyArgs ? function getKey() {\n    return makeCacheKey.apply(null, keyArgs.apply(null, arguments));\n  } : makeCacheKey;\n  return Object.freeze(optimistic);\n}\n\nexport { defaultMakeCacheKey, dep, wrap };","map":{"version":3,"names":["Trie","KeyTrie","Slot","asyncFromGen","bind","bindContext","noContext","setTimeout","defaultDispose","Cache","max","dispose","Infinity","map","Map","newest","oldest","prototype","has","key","get","node","getNode","value","older","newer","set","clean","size","delete","parentEntrySlot","_a","hasOwnProperty","Object","toArray","Array","from","collection","array","forEach","item","push","maybeUnsubscribe","entryOrDep","unsubscribe","emptySetPool","POOL_TARGET_SIZE","assert","condition","optionalMessage","Error","valueIs","a","b","len","length","valueGet","valueCopy","slice","Entry","fn","parents","Set","childValues","dirtyChildren","dirty","recomputing","deps","count","peek","mightBeDirty","rememberParent","recompute","args","reallyRecompute","setDirty","reportDirty","_this","forgetChildren","eachParent","parent","child","forgetChild","forget","dependOn","dep","add","pop","forgetDeps","clear","getValue","reportDirtyChild","reportCleanChild","entry","withValue","recomputeNewValue","maybeSubscribe","setClean","apply","e","reportClean","callback","parentCount","i","parentWasClean","childValue","removeDirtyChild","dc","_value","subscribe","EntryMethods","options","depsByKey","depend","dep_1","entryMethodName","m_1","call","makeDefaultMakeCacheKeyFunction","keyTrie","WeakMap","lookupArray","arguments","defaultMakeCacheKey","caches","wrap","originalFunction","create","cache","Math","pow","keyArgs","makeCacheKey","optimistic","hasValue","defineProperty","configurable","enumerable","dirtyKey","peekKey","forgetKey","getKey","freeze"],"sources":["F:/Bureau/Test_MachinesTalk/MachinesTalk/node_modules/optimism/lib/bundle.esm.js"],"sourcesContent":["import { Trie } from '@wry/trie';\nexport { Trie as KeyTrie } from '@wry/trie';\nimport { Slot } from '@wry/context';\nexport { asyncFromGen, bind as bindContext, noContext, setTimeout } from '@wry/context';\n\nfunction defaultDispose() { }\r\nvar Cache = /** @class */ (function () {\r\n    function Cache(max, dispose) {\r\n        if (max === void 0) { max = Infinity; }\r\n        if (dispose === void 0) { dispose = defaultDispose; }\r\n        this.max = max;\r\n        this.dispose = dispose;\r\n        this.map = new Map();\r\n        this.newest = null;\r\n        this.oldest = null;\r\n    }\r\n    Cache.prototype.has = function (key) {\r\n        return this.map.has(key);\r\n    };\r\n    Cache.prototype.get = function (key) {\r\n        var node = this.getNode(key);\r\n        return node && node.value;\r\n    };\r\n    Cache.prototype.getNode = function (key) {\r\n        var node = this.map.get(key);\r\n        if (node && node !== this.newest) {\r\n            var older = node.older, newer = node.newer;\r\n            if (newer) {\r\n                newer.older = older;\r\n            }\r\n            if (older) {\r\n                older.newer = newer;\r\n            }\r\n            node.older = this.newest;\r\n            node.older.newer = node;\r\n            node.newer = null;\r\n            this.newest = node;\r\n            if (node === this.oldest) {\r\n                this.oldest = newer;\r\n            }\r\n        }\r\n        return node;\r\n    };\r\n    Cache.prototype.set = function (key, value) {\r\n        var node = this.getNode(key);\r\n        if (node) {\r\n            return node.value = value;\r\n        }\r\n        node = {\r\n            key: key,\r\n            value: value,\r\n            newer: null,\r\n            older: this.newest\r\n        };\r\n        if (this.newest) {\r\n            this.newest.newer = node;\r\n        }\r\n        this.newest = node;\r\n        this.oldest = this.oldest || node;\r\n        this.map.set(key, node);\r\n        return node.value;\r\n    };\r\n    Cache.prototype.clean = function () {\r\n        while (this.oldest && this.map.size > this.max) {\r\n            this.delete(this.oldest.key);\r\n        }\r\n    };\r\n    Cache.prototype.delete = function (key) {\r\n        var node = this.map.get(key);\r\n        if (node) {\r\n            if (node === this.newest) {\r\n                this.newest = node.older;\r\n            }\r\n            if (node === this.oldest) {\r\n                this.oldest = node.newer;\r\n            }\r\n            if (node.newer) {\r\n                node.newer.older = node.older;\r\n            }\r\n            if (node.older) {\r\n                node.older.newer = node.newer;\r\n            }\r\n            this.map.delete(key);\r\n            this.dispose(node.value, key);\r\n            return true;\r\n        }\r\n        return false;\r\n    };\r\n    return Cache;\r\n}());\n\nvar parentEntrySlot = new Slot();\n\nvar _a;\r\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\r\nvar \r\n// This Array.from polyfill is restricted to working with Set<any> for now,\r\n// but we can improve the polyfill and add other input types, as needed. Note\r\n// that this fallback implementation will only be used if the host environment\r\n// does not support a native Array.from function. In most modern JS runtimes,\r\n// the toArray function exported here will be === Array.from.\r\ntoArray = (_a = Array.from, _a === void 0 ? function (collection) {\r\n    var array = [];\r\n    collection.forEach(function (item) { return array.push(item); });\r\n    return array;\r\n} : _a);\r\nfunction maybeUnsubscribe(entryOrDep) {\r\n    var unsubscribe = entryOrDep.unsubscribe;\r\n    if (typeof unsubscribe === \"function\") {\r\n        entryOrDep.unsubscribe = void 0;\r\n        unsubscribe();\r\n    }\r\n}\n\nvar emptySetPool = [];\r\nvar POOL_TARGET_SIZE = 100;\r\n// Since this package might be used browsers, we should avoid using the\r\n// Node built-in assert module.\r\nfunction assert(condition, optionalMessage) {\r\n    if (!condition) {\r\n        throw new Error(optionalMessage || \"assertion failure\");\r\n    }\r\n}\r\nfunction valueIs(a, b) {\r\n    var len = a.length;\r\n    return (\r\n    // Unknown values are not equal to each other.\r\n    len > 0 &&\r\n        // Both values must be ordinary (or both exceptional) to be equal.\r\n        len === b.length &&\r\n        // The underlying value or exception must be the same.\r\n        a[len - 1] === b[len - 1]);\r\n}\r\nfunction valueGet(value) {\r\n    switch (value.length) {\r\n        case 0: throw new Error(\"unknown value\");\r\n        case 1: return value[0];\r\n        case 2: throw value[1];\r\n    }\r\n}\r\nfunction valueCopy(value) {\r\n    return value.slice(0);\r\n}\r\nvar Entry = /** @class */ (function () {\r\n    function Entry(fn) {\r\n        this.fn = fn;\r\n        this.parents = new Set();\r\n        this.childValues = new Map();\r\n        // When this Entry has children that are dirty, this property becomes\r\n        // a Set containing other Entry objects, borrowed from emptySetPool.\r\n        // When the set becomes empty, it gets recycled back to emptySetPool.\r\n        this.dirtyChildren = null;\r\n        this.dirty = true;\r\n        this.recomputing = false;\r\n        this.value = [];\r\n        this.deps = null;\r\n        ++Entry.count;\r\n    }\r\n    Entry.prototype.peek = function () {\r\n        if (this.value.length === 1 && !mightBeDirty(this)) {\r\n            rememberParent(this);\r\n            return this.value[0];\r\n        }\r\n    };\r\n    // This is the most important method of the Entry API, because it\r\n    // determines whether the cached this.value can be returned immediately,\r\n    // or must be recomputed. The overall performance of the caching system\r\n    // depends on the truth of the following observations: (1) this.dirty is\r\n    // usually false, (2) this.dirtyChildren is usually null/empty, and thus\r\n    // (3) valueGet(this.value) is usually returned without recomputation.\r\n    Entry.prototype.recompute = function (args) {\r\n        assert(!this.recomputing, \"already recomputing\");\r\n        rememberParent(this);\r\n        return mightBeDirty(this)\r\n            ? reallyRecompute(this, args)\r\n            : valueGet(this.value);\r\n    };\r\n    Entry.prototype.setDirty = function () {\r\n        if (this.dirty)\r\n            return;\r\n        this.dirty = true;\r\n        this.value.length = 0;\r\n        reportDirty(this);\r\n        // We can go ahead and unsubscribe here, since any further dirty\r\n        // notifications we receive will be redundant, and unsubscribing may\r\n        // free up some resources, e.g. file watchers.\r\n        maybeUnsubscribe(this);\r\n    };\r\n    Entry.prototype.dispose = function () {\r\n        var _this = this;\r\n        this.setDirty();\r\n        // Sever any dependency relationships with our own children, so those\r\n        // children don't retain this parent Entry in their child.parents sets,\r\n        // thereby preventing it from being fully garbage collected.\r\n        forgetChildren(this);\r\n        // Because this entry has been kicked out of the cache (in index.js),\r\n        // we've lost the ability to find out if/when this entry becomes dirty,\r\n        // whether that happens through a subscription, because of a direct call\r\n        // to entry.setDirty(), or because one of its children becomes dirty.\r\n        // Because of this loss of future information, we have to assume the\r\n        // worst (that this entry might have become dirty very soon), so we must\r\n        // immediately mark this entry's parents as dirty. Normally we could\r\n        // just call entry.setDirty() rather than calling parent.setDirty() for\r\n        // each parent, but that would leave this entry in parent.childValues\r\n        // and parent.dirtyChildren, which would prevent the child from being\r\n        // truly forgotten.\r\n        eachParent(this, function (parent, child) {\r\n            parent.setDirty();\r\n            forgetChild(parent, _this);\r\n        });\r\n    };\r\n    Entry.prototype.forget = function () {\r\n        // The code that creates Entry objects in index.ts will replace this method\r\n        // with one that actually removes the Entry from the cache, which will also\r\n        // trigger the entry.dispose method.\r\n        this.dispose();\r\n    };\r\n    Entry.prototype.dependOn = function (dep) {\r\n        dep.add(this);\r\n        if (!this.deps) {\r\n            this.deps = emptySetPool.pop() || new Set();\r\n        }\r\n        this.deps.add(dep);\r\n    };\r\n    Entry.prototype.forgetDeps = function () {\r\n        var _this = this;\r\n        if (this.deps) {\r\n            toArray(this.deps).forEach(function (dep) { return dep.delete(_this); });\r\n            this.deps.clear();\r\n            emptySetPool.push(this.deps);\r\n            this.deps = null;\r\n        }\r\n    };\r\n    Entry.count = 0;\r\n    return Entry;\r\n}());\r\nfunction rememberParent(child) {\r\n    var parent = parentEntrySlot.getValue();\r\n    if (parent) {\r\n        child.parents.add(parent);\r\n        if (!parent.childValues.has(child)) {\r\n            parent.childValues.set(child, []);\r\n        }\r\n        if (mightBeDirty(child)) {\r\n            reportDirtyChild(parent, child);\r\n        }\r\n        else {\r\n            reportCleanChild(parent, child);\r\n        }\r\n        return parent;\r\n    }\r\n}\r\nfunction reallyRecompute(entry, args) {\r\n    forgetChildren(entry);\r\n    // Set entry as the parent entry while calling recomputeNewValue(entry).\r\n    parentEntrySlot.withValue(entry, recomputeNewValue, [entry, args]);\r\n    if (maybeSubscribe(entry, args)) {\r\n        // If we successfully recomputed entry.value and did not fail to\r\n        // (re)subscribe, then this Entry is no longer explicitly dirty.\r\n        setClean(entry);\r\n    }\r\n    return valueGet(entry.value);\r\n}\r\nfunction recomputeNewValue(entry, args) {\r\n    entry.recomputing = true;\r\n    // Set entry.value as unknown.\r\n    entry.value.length = 0;\r\n    try {\r\n        // If entry.fn succeeds, entry.value will become a normal Value.\r\n        entry.value[0] = entry.fn.apply(null, args);\r\n    }\r\n    catch (e) {\r\n        // If entry.fn throws, entry.value will become exceptional.\r\n        entry.value[1] = e;\r\n    }\r\n    // Either way, this line is always reached.\r\n    entry.recomputing = false;\r\n}\r\nfunction mightBeDirty(entry) {\r\n    return entry.dirty || !!(entry.dirtyChildren && entry.dirtyChildren.size);\r\n}\r\nfunction setClean(entry) {\r\n    entry.dirty = false;\r\n    if (mightBeDirty(entry)) {\r\n        // This Entry may still have dirty children, in which case we can't\r\n        // let our parents know we're clean just yet.\r\n        return;\r\n    }\r\n    reportClean(entry);\r\n}\r\nfunction reportDirty(child) {\r\n    eachParent(child, reportDirtyChild);\r\n}\r\nfunction reportClean(child) {\r\n    eachParent(child, reportCleanChild);\r\n}\r\nfunction eachParent(child, callback) {\r\n    var parentCount = child.parents.size;\r\n    if (parentCount) {\r\n        var parents = toArray(child.parents);\r\n        for (var i = 0; i < parentCount; ++i) {\r\n            callback(parents[i], child);\r\n        }\r\n    }\r\n}\r\n// Let a parent Entry know that one of its children may be dirty.\r\nfunction reportDirtyChild(parent, child) {\r\n    // Must have called rememberParent(child) before calling\r\n    // reportDirtyChild(parent, child).\r\n    assert(parent.childValues.has(child));\r\n    assert(mightBeDirty(child));\r\n    var parentWasClean = !mightBeDirty(parent);\r\n    if (!parent.dirtyChildren) {\r\n        parent.dirtyChildren = emptySetPool.pop() || new Set;\r\n    }\r\n    else if (parent.dirtyChildren.has(child)) {\r\n        // If we already know this child is dirty, then we must have already\r\n        // informed our own parents that we are dirty, so we can terminate\r\n        // the recursion early.\r\n        return;\r\n    }\r\n    parent.dirtyChildren.add(child);\r\n    // If parent was clean before, it just became (possibly) dirty (according to\r\n    // mightBeDirty), since we just added child to parent.dirtyChildren.\r\n    if (parentWasClean) {\r\n        reportDirty(parent);\r\n    }\r\n}\r\n// Let a parent Entry know that one of its children is no longer dirty.\r\nfunction reportCleanChild(parent, child) {\r\n    // Must have called rememberChild(child) before calling\r\n    // reportCleanChild(parent, child).\r\n    assert(parent.childValues.has(child));\r\n    assert(!mightBeDirty(child));\r\n    var childValue = parent.childValues.get(child);\r\n    if (childValue.length === 0) {\r\n        parent.childValues.set(child, valueCopy(child.value));\r\n    }\r\n    else if (!valueIs(childValue, child.value)) {\r\n        parent.setDirty();\r\n    }\r\n    removeDirtyChild(parent, child);\r\n    if (mightBeDirty(parent)) {\r\n        return;\r\n    }\r\n    reportClean(parent);\r\n}\r\nfunction removeDirtyChild(parent, child) {\r\n    var dc = parent.dirtyChildren;\r\n    if (dc) {\r\n        dc.delete(child);\r\n        if (dc.size === 0) {\r\n            if (emptySetPool.length < POOL_TARGET_SIZE) {\r\n                emptySetPool.push(dc);\r\n            }\r\n            parent.dirtyChildren = null;\r\n        }\r\n    }\r\n}\r\n// Removes all children from this entry and returns an array of the\r\n// removed children.\r\nfunction forgetChildren(parent) {\r\n    if (parent.childValues.size > 0) {\r\n        parent.childValues.forEach(function (_value, child) {\r\n            forgetChild(parent, child);\r\n        });\r\n    }\r\n    // Remove this parent Entry from any sets to which it was added by the\r\n    // addToSet method.\r\n    parent.forgetDeps();\r\n    // After we forget all our children, this.dirtyChildren must be empty\r\n    // and therefore must have been reset to null.\r\n    assert(parent.dirtyChildren === null);\r\n}\r\nfunction forgetChild(parent, child) {\r\n    child.parents.delete(parent);\r\n    parent.childValues.delete(child);\r\n    removeDirtyChild(parent, child);\r\n}\r\nfunction maybeSubscribe(entry, args) {\r\n    if (typeof entry.subscribe === \"function\") {\r\n        try {\r\n            maybeUnsubscribe(entry); // Prevent double subscriptions.\r\n            entry.unsubscribe = entry.subscribe.apply(null, args);\r\n        }\r\n        catch (e) {\r\n            // If this Entry has a subscribe function and it threw an exception\r\n            // (or an unsubscribe function it previously returned now throws),\r\n            // return false to indicate that we were not able to subscribe (or\r\n            // unsubscribe), and this Entry should remain dirty.\r\n            entry.setDirty();\r\n            return false;\r\n        }\r\n    }\r\n    // Returning true indicates either that there was no entry.subscribe\r\n    // function or that it succeeded.\r\n    return true;\r\n}\n\nvar EntryMethods = {\r\n    setDirty: true,\r\n    dispose: true,\r\n    forget: true, // Fully remove parent Entry from LRU cache and computation graph\r\n};\r\nfunction dep(options) {\r\n    var depsByKey = new Map();\r\n    var subscribe = options && options.subscribe;\r\n    function depend(key) {\r\n        var parent = parentEntrySlot.getValue();\r\n        if (parent) {\r\n            var dep_1 = depsByKey.get(key);\r\n            if (!dep_1) {\r\n                depsByKey.set(key, dep_1 = new Set);\r\n            }\r\n            parent.dependOn(dep_1);\r\n            if (typeof subscribe === \"function\") {\r\n                maybeUnsubscribe(dep_1);\r\n                dep_1.unsubscribe = subscribe(key);\r\n            }\r\n        }\r\n    }\r\n    depend.dirty = function dirty(key, entryMethodName) {\r\n        var dep = depsByKey.get(key);\r\n        if (dep) {\r\n            var m_1 = (entryMethodName &&\r\n                hasOwnProperty.call(EntryMethods, entryMethodName)) ? entryMethodName : \"setDirty\";\r\n            // We have to use toArray(dep).forEach instead of dep.forEach, because\r\n            // modifying a Set while iterating over it can cause elements in the Set\r\n            // to be removed from the Set before they've been iterated over.\r\n            toArray(dep).forEach(function (entry) { return entry[m_1](); });\r\n            depsByKey.delete(key);\r\n            maybeUnsubscribe(dep);\r\n        }\r\n    };\r\n    return depend;\r\n}\n\nfunction makeDefaultMakeCacheKeyFunction() {\r\n    var keyTrie = new Trie(typeof WeakMap === \"function\");\r\n    return function () {\r\n        return keyTrie.lookupArray(arguments);\r\n    };\r\n}\r\n// The defaultMakeCacheKey function is remarkably powerful, because it gives\r\n// a unique object for any shallow-identical list of arguments. If you need\r\n// to implement a custom makeCacheKey function, you may find it helpful to\r\n// delegate the final work to defaultMakeCacheKey, which is why we export it\r\n// here. However, you may want to avoid defaultMakeCacheKey if your runtime\r\n// does not support WeakMap, or you have the ability to return a string key.\r\n// In those cases, just write your own custom makeCacheKey functions.\r\nvar defaultMakeCacheKey = makeDefaultMakeCacheKeyFunction();\r\nvar caches = new Set();\r\nfunction wrap(originalFunction, options) {\r\n    if (options === void 0) { options = Object.create(null); }\r\n    var cache = new Cache(options.max || Math.pow(2, 16), function (entry) { return entry.dispose(); });\r\n    var keyArgs = options.keyArgs;\r\n    var makeCacheKey = options.makeCacheKey ||\r\n        makeDefaultMakeCacheKeyFunction();\r\n    var optimistic = function () {\r\n        var key = makeCacheKey.apply(null, keyArgs ? keyArgs.apply(null, arguments) : arguments);\r\n        if (key === void 0) {\r\n            return originalFunction.apply(null, arguments);\r\n        }\r\n        var entry = cache.get(key);\r\n        if (!entry) {\r\n            cache.set(key, entry = new Entry(originalFunction));\r\n            entry.subscribe = options.subscribe;\r\n            // Give the Entry the ability to trigger cache.delete(key), even though\r\n            // the Entry itself does not know about key or cache.\r\n            entry.forget = function () { return cache.delete(key); };\r\n        }\r\n        var value = entry.recompute(Array.prototype.slice.call(arguments));\r\n        // Move this entry to the front of the least-recently used queue,\r\n        // since we just finished computing its value.\r\n        cache.set(key, entry);\r\n        caches.add(cache);\r\n        // Clean up any excess entries in the cache, but only if there is no\r\n        // active parent entry, meaning we're not in the middle of a larger\r\n        // computation that might be flummoxed by the cleaning.\r\n        if (!parentEntrySlot.hasValue()) {\r\n            caches.forEach(function (cache) { return cache.clean(); });\r\n            caches.clear();\r\n        }\r\n        return value;\r\n    };\r\n    Object.defineProperty(optimistic, \"size\", {\r\n        get: function () {\r\n            return cache[\"map\"].size;\r\n        },\r\n        configurable: false,\r\n        enumerable: false,\r\n    });\r\n    function dirtyKey(key) {\r\n        var entry = cache.get(key);\r\n        if (entry) {\r\n            entry.setDirty();\r\n        }\r\n    }\r\n    optimistic.dirtyKey = dirtyKey;\r\n    optimistic.dirty = function dirty() {\r\n        dirtyKey(makeCacheKey.apply(null, arguments));\r\n    };\r\n    function peekKey(key) {\r\n        var entry = cache.get(key);\r\n        if (entry) {\r\n            return entry.peek();\r\n        }\r\n    }\r\n    optimistic.peekKey = peekKey;\r\n    optimistic.peek = function peek() {\r\n        return peekKey(makeCacheKey.apply(null, arguments));\r\n    };\r\n    function forgetKey(key) {\r\n        return cache.delete(key);\r\n    }\r\n    optimistic.forgetKey = forgetKey;\r\n    optimistic.forget = function forget() {\r\n        return forgetKey(makeCacheKey.apply(null, arguments));\r\n    };\r\n    optimistic.makeCacheKey = makeCacheKey;\r\n    optimistic.getKey = keyArgs ? function getKey() {\r\n        return makeCacheKey.apply(null, keyArgs.apply(null, arguments));\r\n    } : makeCacheKey;\r\n    return Object.freeze(optimistic);\r\n}\n\nexport { defaultMakeCacheKey, dep, wrap };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}