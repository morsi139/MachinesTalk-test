{"ast":null,"code":"import { __assign, __rest } from \"tslib\";\nimport { invariant, InvariantError } from \"../../utilities/globals/index.js\";\nimport { storeKeyNameFromField, argumentsObjectFromField, isReference, getStoreKeyName, isNonNullObject, stringifyForDisplay } from \"../../utilities/index.js\";\nimport { hasOwn, fieldNameFromStoreName, storeValueIsStoreObject, selectionSetMatchesResult, TypeOrFieldNameRegExp, defaultDataIdFromObject, isArray } from \"./helpers.js\";\nimport { cacheSlot } from \"./reactiveVars.js\";\nimport { canonicalStringify } from \"./object-canon.js\";\nimport { keyArgsFnFromSpecifier, keyFieldsFnFromSpecifier } from \"./key-extractor.js\";\ngetStoreKeyName.setStringify(canonicalStringify);\n\nfunction argsFromFieldSpecifier(spec) {\n  return spec.args !== void 0 ? spec.args : spec.field ? argumentsObjectFromField(spec.field, spec.variables) : null;\n}\n\nvar nullKeyFieldsFn = function () {\n  return void 0;\n};\n\nvar simpleKeyArgsFn = function (_args, context) {\n  return context.fieldName;\n};\n\nvar mergeTrueFn = function (existing, incoming, _a) {\n  var mergeObjects = _a.mergeObjects;\n  return mergeObjects(existing, incoming);\n};\n\nvar mergeFalseFn = function (_, incoming) {\n  return incoming;\n};\n\nvar Policies = function () {\n  function Policies(config) {\n    this.config = config;\n    this.typePolicies = Object.create(null);\n    this.toBeAdded = Object.create(null);\n    this.supertypeMap = new Map();\n    this.fuzzySubtypes = new Map();\n    this.rootIdsByTypename = Object.create(null);\n    this.rootTypenamesById = Object.create(null);\n    this.usingPossibleTypes = false;\n    this.config = __assign({\n      dataIdFromObject: defaultDataIdFromObject\n    }, config);\n    this.cache = this.config.cache;\n    this.setRootTypename(\"Query\");\n    this.setRootTypename(\"Mutation\");\n    this.setRootTypename(\"Subscription\");\n\n    if (config.possibleTypes) {\n      this.addPossibleTypes(config.possibleTypes);\n    }\n\n    if (config.typePolicies) {\n      this.addTypePolicies(config.typePolicies);\n    }\n  }\n\n  Policies.prototype.identify = function (object, partialContext) {\n    var _a;\n\n    var policies = this;\n    var typename = partialContext && (partialContext.typename || ((_a = partialContext.storeObject) === null || _a === void 0 ? void 0 : _a.__typename)) || object.__typename;\n\n    if (typename === this.rootTypenamesById.ROOT_QUERY) {\n      return [\"ROOT_QUERY\"];\n    }\n\n    var storeObject = partialContext && partialContext.storeObject || object;\n\n    var context = __assign(__assign({}, partialContext), {\n      typename: typename,\n      storeObject: storeObject,\n      readField: partialContext && partialContext.readField || function () {\n        var options = normalizeReadFieldOptions(arguments, storeObject);\n        return policies.readField(options, {\n          store: policies.cache[\"data\"],\n          variables: options.variables\n        });\n      }\n    });\n\n    var id;\n    var policy = typename && this.getTypePolicy(typename);\n    var keyFn = policy && policy.keyFn || this.config.dataIdFromObject;\n\n    while (keyFn) {\n      var specifierOrId = keyFn(object, context);\n\n      if (isArray(specifierOrId)) {\n        keyFn = keyFieldsFnFromSpecifier(specifierOrId);\n      } else {\n        id = specifierOrId;\n        break;\n      }\n    }\n\n    id = id ? String(id) : void 0;\n    return context.keyObject ? [id, context.keyObject] : [id];\n  };\n\n  Policies.prototype.addTypePolicies = function (typePolicies) {\n    var _this = this;\n\n    Object.keys(typePolicies).forEach(function (typename) {\n      var _a = typePolicies[typename],\n          queryType = _a.queryType,\n          mutationType = _a.mutationType,\n          subscriptionType = _a.subscriptionType,\n          incoming = __rest(_a, [\"queryType\", \"mutationType\", \"subscriptionType\"]);\n\n      if (queryType) _this.setRootTypename(\"Query\", typename);\n      if (mutationType) _this.setRootTypename(\"Mutation\", typename);\n      if (subscriptionType) _this.setRootTypename(\"Subscription\", typename);\n\n      if (hasOwn.call(_this.toBeAdded, typename)) {\n        _this.toBeAdded[typename].push(incoming);\n      } else {\n        _this.toBeAdded[typename] = [incoming];\n      }\n    });\n  };\n\n  Policies.prototype.updateTypePolicy = function (typename, incoming) {\n    var _this = this;\n\n    var existing = this.getTypePolicy(typename);\n    var keyFields = incoming.keyFields,\n        fields = incoming.fields;\n\n    function setMerge(existing, merge) {\n      existing.merge = typeof merge === \"function\" ? merge : merge === true ? mergeTrueFn : merge === false ? mergeFalseFn : existing.merge;\n    }\n\n    setMerge(existing, incoming.merge);\n    existing.keyFn = keyFields === false ? nullKeyFieldsFn : isArray(keyFields) ? keyFieldsFnFromSpecifier(keyFields) : typeof keyFields === \"function\" ? keyFields : existing.keyFn;\n\n    if (fields) {\n      Object.keys(fields).forEach(function (fieldName) {\n        var existing = _this.getFieldPolicy(typename, fieldName, true);\n\n        var incoming = fields[fieldName];\n\n        if (typeof incoming === \"function\") {\n          existing.read = incoming;\n        } else {\n          var keyArgs = incoming.keyArgs,\n              read = incoming.read,\n              merge = incoming.merge;\n          existing.keyFn = keyArgs === false ? simpleKeyArgsFn : isArray(keyArgs) ? keyArgsFnFromSpecifier(keyArgs) : typeof keyArgs === \"function\" ? keyArgs : existing.keyFn;\n\n          if (typeof read === \"function\") {\n            existing.read = read;\n          }\n\n          setMerge(existing, merge);\n        }\n\n        if (existing.read && existing.merge) {\n          existing.keyFn = existing.keyFn || simpleKeyArgsFn;\n        }\n      });\n    }\n  };\n\n  Policies.prototype.setRootTypename = function (which, typename) {\n    if (typename === void 0) {\n      typename = which;\n    }\n\n    var rootId = \"ROOT_\" + which.toUpperCase();\n    var old = this.rootTypenamesById[rootId];\n\n    if (typename !== old) {\n      __DEV__ ? invariant(!old || old === which, \"Cannot change root \".concat(which, \" __typename more than once\")) : invariant(!old || old === which, 3);\n      if (old) delete this.rootIdsByTypename[old];\n      this.rootIdsByTypename[typename] = rootId;\n      this.rootTypenamesById[rootId] = typename;\n    }\n  };\n\n  Policies.prototype.addPossibleTypes = function (possibleTypes) {\n    var _this = this;\n\n    this.usingPossibleTypes = true;\n    Object.keys(possibleTypes).forEach(function (supertype) {\n      _this.getSupertypeSet(supertype, true);\n\n      possibleTypes[supertype].forEach(function (subtype) {\n        _this.getSupertypeSet(subtype, true).add(supertype);\n\n        var match = subtype.match(TypeOrFieldNameRegExp);\n\n        if (!match || match[0] !== subtype) {\n          _this.fuzzySubtypes.set(subtype, new RegExp(subtype));\n        }\n      });\n    });\n  };\n\n  Policies.prototype.getTypePolicy = function (typename) {\n    var _this = this;\n\n    if (!hasOwn.call(this.typePolicies, typename)) {\n      var policy_1 = this.typePolicies[typename] = Object.create(null);\n      policy_1.fields = Object.create(null);\n      var supertypes = this.supertypeMap.get(typename);\n\n      if (supertypes && supertypes.size) {\n        supertypes.forEach(function (supertype) {\n          var _a = _this.getTypePolicy(supertype),\n              fields = _a.fields,\n              rest = __rest(_a, [\"fields\"]);\n\n          Object.assign(policy_1, rest);\n          Object.assign(policy_1.fields, fields);\n        });\n      }\n    }\n\n    var inbox = this.toBeAdded[typename];\n\n    if (inbox && inbox.length) {\n      inbox.splice(0).forEach(function (policy) {\n        _this.updateTypePolicy(typename, policy);\n      });\n    }\n\n    return this.typePolicies[typename];\n  };\n\n  Policies.prototype.getFieldPolicy = function (typename, fieldName, createIfMissing) {\n    if (typename) {\n      var fieldPolicies = this.getTypePolicy(typename).fields;\n      return fieldPolicies[fieldName] || createIfMissing && (fieldPolicies[fieldName] = Object.create(null));\n    }\n  };\n\n  Policies.prototype.getSupertypeSet = function (subtype, createIfMissing) {\n    var supertypeSet = this.supertypeMap.get(subtype);\n\n    if (!supertypeSet && createIfMissing) {\n      this.supertypeMap.set(subtype, supertypeSet = new Set());\n    }\n\n    return supertypeSet;\n  };\n\n  Policies.prototype.fragmentMatches = function (fragment, typename, result, variables) {\n    var _this = this;\n\n    if (!fragment.typeCondition) return true;\n    if (!typename) return false;\n    var supertype = fragment.typeCondition.name.value;\n    if (typename === supertype) return true;\n\n    if (this.usingPossibleTypes && this.supertypeMap.has(supertype)) {\n      var typenameSupertypeSet = this.getSupertypeSet(typename, true);\n      var workQueue_1 = [typenameSupertypeSet];\n\n      var maybeEnqueue_1 = function (subtype) {\n        var supertypeSet = _this.getSupertypeSet(subtype, false);\n\n        if (supertypeSet && supertypeSet.size && workQueue_1.indexOf(supertypeSet) < 0) {\n          workQueue_1.push(supertypeSet);\n        }\n      };\n\n      var needToCheckFuzzySubtypes = !!(result && this.fuzzySubtypes.size);\n      var checkingFuzzySubtypes = false;\n\n      for (var i = 0; i < workQueue_1.length; ++i) {\n        var supertypeSet = workQueue_1[i];\n\n        if (supertypeSet.has(supertype)) {\n          if (!typenameSupertypeSet.has(supertype)) {\n            if (checkingFuzzySubtypes) {\n              __DEV__ && invariant.warn(\"Inferring subtype \".concat(typename, \" of supertype \").concat(supertype));\n            }\n\n            typenameSupertypeSet.add(supertype);\n          }\n\n          return true;\n        }\n\n        supertypeSet.forEach(maybeEnqueue_1);\n\n        if (needToCheckFuzzySubtypes && i === workQueue_1.length - 1 && selectionSetMatchesResult(fragment.selectionSet, result, variables)) {\n          needToCheckFuzzySubtypes = false;\n          checkingFuzzySubtypes = true;\n          this.fuzzySubtypes.forEach(function (regExp, fuzzyString) {\n            var match = typename.match(regExp);\n\n            if (match && match[0] === typename) {\n              maybeEnqueue_1(fuzzyString);\n            }\n          });\n        }\n      }\n    }\n\n    return false;\n  };\n\n  Policies.prototype.hasKeyArgs = function (typename, fieldName) {\n    var policy = this.getFieldPolicy(typename, fieldName, false);\n    return !!(policy && policy.keyFn);\n  };\n\n  Policies.prototype.getStoreFieldName = function (fieldSpec) {\n    var typename = fieldSpec.typename,\n        fieldName = fieldSpec.fieldName;\n    var policy = this.getFieldPolicy(typename, fieldName, false);\n    var storeFieldName;\n    var keyFn = policy && policy.keyFn;\n\n    if (keyFn && typename) {\n      var context = {\n        typename: typename,\n        fieldName: fieldName,\n        field: fieldSpec.field || null,\n        variables: fieldSpec.variables\n      };\n      var args = argsFromFieldSpecifier(fieldSpec);\n\n      while (keyFn) {\n        var specifierOrString = keyFn(args, context);\n\n        if (isArray(specifierOrString)) {\n          keyFn = keyArgsFnFromSpecifier(specifierOrString);\n        } else {\n          storeFieldName = specifierOrString || fieldName;\n          break;\n        }\n      }\n    }\n\n    if (storeFieldName === void 0) {\n      storeFieldName = fieldSpec.field ? storeKeyNameFromField(fieldSpec.field, fieldSpec.variables) : getStoreKeyName(fieldName, argsFromFieldSpecifier(fieldSpec));\n    }\n\n    if (storeFieldName === false) {\n      return fieldName;\n    }\n\n    return fieldName === fieldNameFromStoreName(storeFieldName) ? storeFieldName : fieldName + \":\" + storeFieldName;\n  };\n\n  Policies.prototype.readField = function (options, context) {\n    var objectOrReference = options.from;\n    if (!objectOrReference) return;\n    var nameOrField = options.field || options.fieldName;\n    if (!nameOrField) return;\n\n    if (options.typename === void 0) {\n      var typename = context.store.getFieldValue(objectOrReference, \"__typename\");\n      if (typename) options.typename = typename;\n    }\n\n    var storeFieldName = this.getStoreFieldName(options);\n    var fieldName = fieldNameFromStoreName(storeFieldName);\n    var existing = context.store.getFieldValue(objectOrReference, storeFieldName);\n    var policy = this.getFieldPolicy(options.typename, fieldName, false);\n    var read = policy && policy.read;\n\n    if (read) {\n      var readOptions = makeFieldFunctionOptions(this, objectOrReference, options, context, context.store.getStorage(isReference(objectOrReference) ? objectOrReference.__ref : objectOrReference, storeFieldName));\n      return cacheSlot.withValue(this.cache, read, [existing, readOptions]);\n    }\n\n    return existing;\n  };\n\n  Policies.prototype.getReadFunction = function (typename, fieldName) {\n    var policy = this.getFieldPolicy(typename, fieldName, false);\n    return policy && policy.read;\n  };\n\n  Policies.prototype.getMergeFunction = function (parentTypename, fieldName, childTypename) {\n    var policy = this.getFieldPolicy(parentTypename, fieldName, false);\n    var merge = policy && policy.merge;\n\n    if (!merge && childTypename) {\n      policy = this.getTypePolicy(childTypename);\n      merge = policy && policy.merge;\n    }\n\n    return merge;\n  };\n\n  Policies.prototype.runMergeFunction = function (existing, incoming, _a, context, storage) {\n    var field = _a.field,\n        typename = _a.typename,\n        merge = _a.merge;\n\n    if (merge === mergeTrueFn) {\n      return makeMergeObjectsFunction(context.store)(existing, incoming);\n    }\n\n    if (merge === mergeFalseFn) {\n      return incoming;\n    }\n\n    if (context.overwrite) {\n      existing = void 0;\n    }\n\n    return merge(existing, incoming, makeFieldFunctionOptions(this, void 0, {\n      typename: typename,\n      fieldName: field.name.value,\n      field: field,\n      variables: context.variables\n    }, context, storage || Object.create(null)));\n  };\n\n  return Policies;\n}();\n\nexport { Policies };\n\nfunction makeFieldFunctionOptions(policies, objectOrReference, fieldSpec, context, storage) {\n  var storeFieldName = policies.getStoreFieldName(fieldSpec);\n  var fieldName = fieldNameFromStoreName(storeFieldName);\n  var variables = fieldSpec.variables || context.variables;\n  var _a = context.store,\n      toReference = _a.toReference,\n      canRead = _a.canRead;\n  return {\n    args: argsFromFieldSpecifier(fieldSpec),\n    field: fieldSpec.field || null,\n    fieldName: fieldName,\n    storeFieldName: storeFieldName,\n    variables: variables,\n    isReference: isReference,\n    toReference: toReference,\n    storage: storage,\n    cache: policies.cache,\n    canRead: canRead,\n    readField: function () {\n      return policies.readField(normalizeReadFieldOptions(arguments, objectOrReference, variables), context);\n    },\n    mergeObjects: makeMergeObjectsFunction(context.store)\n  };\n}\n\nexport function normalizeReadFieldOptions(readFieldArgs, objectOrReference, variables) {\n  var fieldNameOrOptions = readFieldArgs[0],\n      from = readFieldArgs[1],\n      argc = readFieldArgs.length;\n  var options;\n\n  if (typeof fieldNameOrOptions === \"string\") {\n    options = {\n      fieldName: fieldNameOrOptions,\n      from: argc > 1 ? from : objectOrReference\n    };\n  } else {\n    options = __assign({}, fieldNameOrOptions);\n\n    if (!hasOwn.call(options, \"from\")) {\n      options.from = objectOrReference;\n    }\n  }\n\n  if (__DEV__ && options.from === void 0) {\n    __DEV__ && invariant.warn(\"Undefined 'from' passed to readField with arguments \".concat(stringifyForDisplay(Array.from(readFieldArgs))));\n  }\n\n  if (void 0 === options.variables) {\n    options.variables = variables;\n  }\n\n  return options;\n}\n\nfunction makeMergeObjectsFunction(store) {\n  return function mergeObjects(existing, incoming) {\n    if (isArray(existing) || isArray(incoming)) {\n      throw __DEV__ ? new InvariantError(\"Cannot automatically merge arrays\") : new InvariantError(4);\n    }\n\n    if (isNonNullObject(existing) && isNonNullObject(incoming)) {\n      var eType = store.getFieldValue(existing, \"__typename\");\n      var iType = store.getFieldValue(incoming, \"__typename\");\n      var typesDiffer = eType && iType && eType !== iType;\n\n      if (typesDiffer) {\n        return incoming;\n      }\n\n      if (isReference(existing) && storeValueIsStoreObject(incoming)) {\n        store.merge(existing.__ref, incoming);\n        return existing;\n      }\n\n      if (storeValueIsStoreObject(existing) && isReference(incoming)) {\n        store.merge(existing, incoming.__ref);\n        return incoming;\n      }\n\n      if (storeValueIsStoreObject(existing) && storeValueIsStoreObject(incoming)) {\n        return __assign(__assign({}, existing), incoming);\n      }\n    }\n\n    return incoming;\n  };\n}","map":{"version":3,"names":["__assign","__rest","invariant","InvariantError","storeKeyNameFromField","argumentsObjectFromField","isReference","getStoreKeyName","isNonNullObject","stringifyForDisplay","hasOwn","fieldNameFromStoreName","storeValueIsStoreObject","selectionSetMatchesResult","TypeOrFieldNameRegExp","defaultDataIdFromObject","isArray","cacheSlot","canonicalStringify","keyArgsFnFromSpecifier","keyFieldsFnFromSpecifier","setStringify","argsFromFieldSpecifier","spec","args","field","variables","nullKeyFieldsFn","simpleKeyArgsFn","_args","context","fieldName","mergeTrueFn","existing","incoming","_a","mergeObjects","mergeFalseFn","_","Policies","config","typePolicies","Object","create","toBeAdded","supertypeMap","Map","fuzzySubtypes","rootIdsByTypename","rootTypenamesById","usingPossibleTypes","dataIdFromObject","cache","setRootTypename","possibleTypes","addPossibleTypes","addTypePolicies","prototype","identify","object","partialContext","policies","typename","storeObject","__typename","ROOT_QUERY","readField","options","normalizeReadFieldOptions","arguments","store","id","policy","getTypePolicy","keyFn","specifierOrId","String","keyObject","_this","keys","forEach","queryType","mutationType","subscriptionType","call","push","updateTypePolicy","keyFields","fields","setMerge","merge","getFieldPolicy","read","keyArgs","which","rootId","toUpperCase","old","__DEV__","concat","supertype","getSupertypeSet","subtype","add","match","set","RegExp","policy_1","supertypes","get","size","rest","assign","inbox","length","splice","createIfMissing","fieldPolicies","supertypeSet","Set","fragmentMatches","fragment","result","typeCondition","name","value","has","typenameSupertypeSet","workQueue_1","maybeEnqueue_1","indexOf","needToCheckFuzzySubtypes","checkingFuzzySubtypes","i","warn","selectionSet","regExp","fuzzyString","hasKeyArgs","getStoreFieldName","fieldSpec","storeFieldName","specifierOrString","objectOrReference","from","nameOrField","getFieldValue","readOptions","makeFieldFunctionOptions","getStorage","__ref","withValue","getReadFunction","getMergeFunction","parentTypename","childTypename","runMergeFunction","storage","makeMergeObjectsFunction","overwrite","toReference","canRead","readFieldArgs","fieldNameOrOptions","argc","Array","eType","iType","typesDiffer"],"sources":["F:/Bureau/Test_MachinesTalk/MachinesTalk/node_modules/@apollo/client/cache/inmemory/policies.js"],"sourcesContent":["import { __assign, __rest } from \"tslib\";\nimport { invariant, InvariantError } from \"../../utilities/globals/index.js\";\nimport { storeKeyNameFromField, argumentsObjectFromField, isReference, getStoreKeyName, isNonNullObject, stringifyForDisplay, } from \"../../utilities/index.js\";\nimport { hasOwn, fieldNameFromStoreName, storeValueIsStoreObject, selectionSetMatchesResult, TypeOrFieldNameRegExp, defaultDataIdFromObject, isArray, } from \"./helpers.js\";\nimport { cacheSlot } from \"./reactiveVars.js\";\nimport { canonicalStringify } from \"./object-canon.js\";\nimport { keyArgsFnFromSpecifier, keyFieldsFnFromSpecifier } from \"./key-extractor.js\";\ngetStoreKeyName.setStringify(canonicalStringify);\nfunction argsFromFieldSpecifier(spec) {\n    return spec.args !== void 0 ? spec.args :\n        spec.field ? argumentsObjectFromField(spec.field, spec.variables) : null;\n}\nvar nullKeyFieldsFn = function () { return void 0; };\nvar simpleKeyArgsFn = function (_args, context) { return context.fieldName; };\nvar mergeTrueFn = function (existing, incoming, _a) {\n    var mergeObjects = _a.mergeObjects;\n    return mergeObjects(existing, incoming);\n};\nvar mergeFalseFn = function (_, incoming) { return incoming; };\nvar Policies = (function () {\n    function Policies(config) {\n        this.config = config;\n        this.typePolicies = Object.create(null);\n        this.toBeAdded = Object.create(null);\n        this.supertypeMap = new Map();\n        this.fuzzySubtypes = new Map();\n        this.rootIdsByTypename = Object.create(null);\n        this.rootTypenamesById = Object.create(null);\n        this.usingPossibleTypes = false;\n        this.config = __assign({ dataIdFromObject: defaultDataIdFromObject }, config);\n        this.cache = this.config.cache;\n        this.setRootTypename(\"Query\");\n        this.setRootTypename(\"Mutation\");\n        this.setRootTypename(\"Subscription\");\n        if (config.possibleTypes) {\n            this.addPossibleTypes(config.possibleTypes);\n        }\n        if (config.typePolicies) {\n            this.addTypePolicies(config.typePolicies);\n        }\n    }\n    Policies.prototype.identify = function (object, partialContext) {\n        var _a;\n        var policies = this;\n        var typename = partialContext && (partialContext.typename ||\n            ((_a = partialContext.storeObject) === null || _a === void 0 ? void 0 : _a.__typename)) || object.__typename;\n        if (typename === this.rootTypenamesById.ROOT_QUERY) {\n            return [\"ROOT_QUERY\"];\n        }\n        var storeObject = partialContext && partialContext.storeObject || object;\n        var context = __assign(__assign({}, partialContext), { typename: typename, storeObject: storeObject, readField: partialContext && partialContext.readField || function () {\n                var options = normalizeReadFieldOptions(arguments, storeObject);\n                return policies.readField(options, {\n                    store: policies.cache[\"data\"],\n                    variables: options.variables,\n                });\n            } });\n        var id;\n        var policy = typename && this.getTypePolicy(typename);\n        var keyFn = policy && policy.keyFn || this.config.dataIdFromObject;\n        while (keyFn) {\n            var specifierOrId = keyFn(object, context);\n            if (isArray(specifierOrId)) {\n                keyFn = keyFieldsFnFromSpecifier(specifierOrId);\n            }\n            else {\n                id = specifierOrId;\n                break;\n            }\n        }\n        id = id ? String(id) : void 0;\n        return context.keyObject ? [id, context.keyObject] : [id];\n    };\n    Policies.prototype.addTypePolicies = function (typePolicies) {\n        var _this = this;\n        Object.keys(typePolicies).forEach(function (typename) {\n            var _a = typePolicies[typename], queryType = _a.queryType, mutationType = _a.mutationType, subscriptionType = _a.subscriptionType, incoming = __rest(_a, [\"queryType\", \"mutationType\", \"subscriptionType\"]);\n            if (queryType)\n                _this.setRootTypename(\"Query\", typename);\n            if (mutationType)\n                _this.setRootTypename(\"Mutation\", typename);\n            if (subscriptionType)\n                _this.setRootTypename(\"Subscription\", typename);\n            if (hasOwn.call(_this.toBeAdded, typename)) {\n                _this.toBeAdded[typename].push(incoming);\n            }\n            else {\n                _this.toBeAdded[typename] = [incoming];\n            }\n        });\n    };\n    Policies.prototype.updateTypePolicy = function (typename, incoming) {\n        var _this = this;\n        var existing = this.getTypePolicy(typename);\n        var keyFields = incoming.keyFields, fields = incoming.fields;\n        function setMerge(existing, merge) {\n            existing.merge =\n                typeof merge === \"function\" ? merge :\n                    merge === true ? mergeTrueFn :\n                        merge === false ? mergeFalseFn :\n                            existing.merge;\n        }\n        setMerge(existing, incoming.merge);\n        existing.keyFn =\n            keyFields === false ? nullKeyFieldsFn :\n                isArray(keyFields) ? keyFieldsFnFromSpecifier(keyFields) :\n                    typeof keyFields === \"function\" ? keyFields :\n                        existing.keyFn;\n        if (fields) {\n            Object.keys(fields).forEach(function (fieldName) {\n                var existing = _this.getFieldPolicy(typename, fieldName, true);\n                var incoming = fields[fieldName];\n                if (typeof incoming === \"function\") {\n                    existing.read = incoming;\n                }\n                else {\n                    var keyArgs = incoming.keyArgs, read = incoming.read, merge = incoming.merge;\n                    existing.keyFn =\n                        keyArgs === false ? simpleKeyArgsFn :\n                            isArray(keyArgs) ? keyArgsFnFromSpecifier(keyArgs) :\n                                typeof keyArgs === \"function\" ? keyArgs :\n                                    existing.keyFn;\n                    if (typeof read === \"function\") {\n                        existing.read = read;\n                    }\n                    setMerge(existing, merge);\n                }\n                if (existing.read && existing.merge) {\n                    existing.keyFn = existing.keyFn || simpleKeyArgsFn;\n                }\n            });\n        }\n    };\n    Policies.prototype.setRootTypename = function (which, typename) {\n        if (typename === void 0) { typename = which; }\n        var rootId = \"ROOT_\" + which.toUpperCase();\n        var old = this.rootTypenamesById[rootId];\n        if (typename !== old) {\n            __DEV__ ? invariant(!old || old === which, \"Cannot change root \".concat(which, \" __typename more than once\")) : invariant(!old || old === which, 3);\n            if (old)\n                delete this.rootIdsByTypename[old];\n            this.rootIdsByTypename[typename] = rootId;\n            this.rootTypenamesById[rootId] = typename;\n        }\n    };\n    Policies.prototype.addPossibleTypes = function (possibleTypes) {\n        var _this = this;\n        this.usingPossibleTypes = true;\n        Object.keys(possibleTypes).forEach(function (supertype) {\n            _this.getSupertypeSet(supertype, true);\n            possibleTypes[supertype].forEach(function (subtype) {\n                _this.getSupertypeSet(subtype, true).add(supertype);\n                var match = subtype.match(TypeOrFieldNameRegExp);\n                if (!match || match[0] !== subtype) {\n                    _this.fuzzySubtypes.set(subtype, new RegExp(subtype));\n                }\n            });\n        });\n    };\n    Policies.prototype.getTypePolicy = function (typename) {\n        var _this = this;\n        if (!hasOwn.call(this.typePolicies, typename)) {\n            var policy_1 = this.typePolicies[typename] = Object.create(null);\n            policy_1.fields = Object.create(null);\n            var supertypes = this.supertypeMap.get(typename);\n            if (supertypes && supertypes.size) {\n                supertypes.forEach(function (supertype) {\n                    var _a = _this.getTypePolicy(supertype), fields = _a.fields, rest = __rest(_a, [\"fields\"]);\n                    Object.assign(policy_1, rest);\n                    Object.assign(policy_1.fields, fields);\n                });\n            }\n        }\n        var inbox = this.toBeAdded[typename];\n        if (inbox && inbox.length) {\n            inbox.splice(0).forEach(function (policy) {\n                _this.updateTypePolicy(typename, policy);\n            });\n        }\n        return this.typePolicies[typename];\n    };\n    Policies.prototype.getFieldPolicy = function (typename, fieldName, createIfMissing) {\n        if (typename) {\n            var fieldPolicies = this.getTypePolicy(typename).fields;\n            return fieldPolicies[fieldName] || (createIfMissing && (fieldPolicies[fieldName] = Object.create(null)));\n        }\n    };\n    Policies.prototype.getSupertypeSet = function (subtype, createIfMissing) {\n        var supertypeSet = this.supertypeMap.get(subtype);\n        if (!supertypeSet && createIfMissing) {\n            this.supertypeMap.set(subtype, supertypeSet = new Set());\n        }\n        return supertypeSet;\n    };\n    Policies.prototype.fragmentMatches = function (fragment, typename, result, variables) {\n        var _this = this;\n        if (!fragment.typeCondition)\n            return true;\n        if (!typename)\n            return false;\n        var supertype = fragment.typeCondition.name.value;\n        if (typename === supertype)\n            return true;\n        if (this.usingPossibleTypes &&\n            this.supertypeMap.has(supertype)) {\n            var typenameSupertypeSet = this.getSupertypeSet(typename, true);\n            var workQueue_1 = [typenameSupertypeSet];\n            var maybeEnqueue_1 = function (subtype) {\n                var supertypeSet = _this.getSupertypeSet(subtype, false);\n                if (supertypeSet &&\n                    supertypeSet.size &&\n                    workQueue_1.indexOf(supertypeSet) < 0) {\n                    workQueue_1.push(supertypeSet);\n                }\n            };\n            var needToCheckFuzzySubtypes = !!(result && this.fuzzySubtypes.size);\n            var checkingFuzzySubtypes = false;\n            for (var i = 0; i < workQueue_1.length; ++i) {\n                var supertypeSet = workQueue_1[i];\n                if (supertypeSet.has(supertype)) {\n                    if (!typenameSupertypeSet.has(supertype)) {\n                        if (checkingFuzzySubtypes) {\n                            __DEV__ && invariant.warn(\"Inferring subtype \".concat(typename, \" of supertype \").concat(supertype));\n                        }\n                        typenameSupertypeSet.add(supertype);\n                    }\n                    return true;\n                }\n                supertypeSet.forEach(maybeEnqueue_1);\n                if (needToCheckFuzzySubtypes &&\n                    i === workQueue_1.length - 1 &&\n                    selectionSetMatchesResult(fragment.selectionSet, result, variables)) {\n                    needToCheckFuzzySubtypes = false;\n                    checkingFuzzySubtypes = true;\n                    this.fuzzySubtypes.forEach(function (regExp, fuzzyString) {\n                        var match = typename.match(regExp);\n                        if (match && match[0] === typename) {\n                            maybeEnqueue_1(fuzzyString);\n                        }\n                    });\n                }\n            }\n        }\n        return false;\n    };\n    Policies.prototype.hasKeyArgs = function (typename, fieldName) {\n        var policy = this.getFieldPolicy(typename, fieldName, false);\n        return !!(policy && policy.keyFn);\n    };\n    Policies.prototype.getStoreFieldName = function (fieldSpec) {\n        var typename = fieldSpec.typename, fieldName = fieldSpec.fieldName;\n        var policy = this.getFieldPolicy(typename, fieldName, false);\n        var storeFieldName;\n        var keyFn = policy && policy.keyFn;\n        if (keyFn && typename) {\n            var context = {\n                typename: typename,\n                fieldName: fieldName,\n                field: fieldSpec.field || null,\n                variables: fieldSpec.variables,\n            };\n            var args = argsFromFieldSpecifier(fieldSpec);\n            while (keyFn) {\n                var specifierOrString = keyFn(args, context);\n                if (isArray(specifierOrString)) {\n                    keyFn = keyArgsFnFromSpecifier(specifierOrString);\n                }\n                else {\n                    storeFieldName = specifierOrString || fieldName;\n                    break;\n                }\n            }\n        }\n        if (storeFieldName === void 0) {\n            storeFieldName = fieldSpec.field\n                ? storeKeyNameFromField(fieldSpec.field, fieldSpec.variables)\n                : getStoreKeyName(fieldName, argsFromFieldSpecifier(fieldSpec));\n        }\n        if (storeFieldName === false) {\n            return fieldName;\n        }\n        return fieldName === fieldNameFromStoreName(storeFieldName)\n            ? storeFieldName\n            : fieldName + \":\" + storeFieldName;\n    };\n    Policies.prototype.readField = function (options, context) {\n        var objectOrReference = options.from;\n        if (!objectOrReference)\n            return;\n        var nameOrField = options.field || options.fieldName;\n        if (!nameOrField)\n            return;\n        if (options.typename === void 0) {\n            var typename = context.store.getFieldValue(objectOrReference, \"__typename\");\n            if (typename)\n                options.typename = typename;\n        }\n        var storeFieldName = this.getStoreFieldName(options);\n        var fieldName = fieldNameFromStoreName(storeFieldName);\n        var existing = context.store.getFieldValue(objectOrReference, storeFieldName);\n        var policy = this.getFieldPolicy(options.typename, fieldName, false);\n        var read = policy && policy.read;\n        if (read) {\n            var readOptions = makeFieldFunctionOptions(this, objectOrReference, options, context, context.store.getStorage(isReference(objectOrReference)\n                ? objectOrReference.__ref\n                : objectOrReference, storeFieldName));\n            return cacheSlot.withValue(this.cache, read, [existing, readOptions]);\n        }\n        return existing;\n    };\n    Policies.prototype.getReadFunction = function (typename, fieldName) {\n        var policy = this.getFieldPolicy(typename, fieldName, false);\n        return policy && policy.read;\n    };\n    Policies.prototype.getMergeFunction = function (parentTypename, fieldName, childTypename) {\n        var policy = this.getFieldPolicy(parentTypename, fieldName, false);\n        var merge = policy && policy.merge;\n        if (!merge && childTypename) {\n            policy = this.getTypePolicy(childTypename);\n            merge = policy && policy.merge;\n        }\n        return merge;\n    };\n    Policies.prototype.runMergeFunction = function (existing, incoming, _a, context, storage) {\n        var field = _a.field, typename = _a.typename, merge = _a.merge;\n        if (merge === mergeTrueFn) {\n            return makeMergeObjectsFunction(context.store)(existing, incoming);\n        }\n        if (merge === mergeFalseFn) {\n            return incoming;\n        }\n        if (context.overwrite) {\n            existing = void 0;\n        }\n        return merge(existing, incoming, makeFieldFunctionOptions(this, void 0, { typename: typename, fieldName: field.name.value, field: field, variables: context.variables }, context, storage || Object.create(null)));\n    };\n    return Policies;\n}());\nexport { Policies };\nfunction makeFieldFunctionOptions(policies, objectOrReference, fieldSpec, context, storage) {\n    var storeFieldName = policies.getStoreFieldName(fieldSpec);\n    var fieldName = fieldNameFromStoreName(storeFieldName);\n    var variables = fieldSpec.variables || context.variables;\n    var _a = context.store, toReference = _a.toReference, canRead = _a.canRead;\n    return {\n        args: argsFromFieldSpecifier(fieldSpec),\n        field: fieldSpec.field || null,\n        fieldName: fieldName,\n        storeFieldName: storeFieldName,\n        variables: variables,\n        isReference: isReference,\n        toReference: toReference,\n        storage: storage,\n        cache: policies.cache,\n        canRead: canRead,\n        readField: function () {\n            return policies.readField(normalizeReadFieldOptions(arguments, objectOrReference, variables), context);\n        },\n        mergeObjects: makeMergeObjectsFunction(context.store),\n    };\n}\nexport function normalizeReadFieldOptions(readFieldArgs, objectOrReference, variables) {\n    var fieldNameOrOptions = readFieldArgs[0], from = readFieldArgs[1], argc = readFieldArgs.length;\n    var options;\n    if (typeof fieldNameOrOptions === \"string\") {\n        options = {\n            fieldName: fieldNameOrOptions,\n            from: argc > 1 ? from : objectOrReference,\n        };\n    }\n    else {\n        options = __assign({}, fieldNameOrOptions);\n        if (!hasOwn.call(options, \"from\")) {\n            options.from = objectOrReference;\n        }\n    }\n    if (__DEV__ && options.from === void 0) {\n        __DEV__ && invariant.warn(\"Undefined 'from' passed to readField with arguments \".concat(stringifyForDisplay(Array.from(readFieldArgs))));\n    }\n    if (void 0 === options.variables) {\n        options.variables = variables;\n    }\n    return options;\n}\nfunction makeMergeObjectsFunction(store) {\n    return function mergeObjects(existing, incoming) {\n        if (isArray(existing) || isArray(incoming)) {\n            throw __DEV__ ? new InvariantError(\"Cannot automatically merge arrays\") : new InvariantError(4);\n        }\n        if (isNonNullObject(existing) &&\n            isNonNullObject(incoming)) {\n            var eType = store.getFieldValue(existing, \"__typename\");\n            var iType = store.getFieldValue(incoming, \"__typename\");\n            var typesDiffer = eType && iType && eType !== iType;\n            if (typesDiffer) {\n                return incoming;\n            }\n            if (isReference(existing) &&\n                storeValueIsStoreObject(incoming)) {\n                store.merge(existing.__ref, incoming);\n                return existing;\n            }\n            if (storeValueIsStoreObject(existing) &&\n                isReference(incoming)) {\n                store.merge(existing, incoming.__ref);\n                return incoming;\n            }\n            if (storeValueIsStoreObject(existing) &&\n                storeValueIsStoreObject(incoming)) {\n                return __assign(__assign({}, existing), incoming);\n            }\n        }\n        return incoming;\n    };\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}