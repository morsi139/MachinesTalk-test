{"ast":null,"code":"import { __assign, __rest as __rest_1, __spreadArray } from \"tslib\";\nimport { __rest } from \"tslib\";\nimport { mergeDeep } from \"../common/mergeDeep.js\";\nexport function concatPagination(keyArgs) {\n  if (keyArgs === void 0) {\n    keyArgs = false;\n  }\n\n  return {\n    keyArgs: keyArgs,\n    merge: function (existing, incoming) {\n      return existing ? __spreadArray(__spreadArray([], existing, true), incoming, true) : incoming;\n    }\n  };\n}\nexport function offsetLimitPagination(keyArgs) {\n  if (keyArgs === void 0) {\n    keyArgs = false;\n  }\n\n  return {\n    keyArgs: keyArgs,\n    merge: function (existing, incoming, _a) {\n      var args = _a.args;\n      var merged = existing ? existing.slice(0) : [];\n\n      if (incoming) {\n        if (args) {\n          var _b = args.offset,\n              offset = _b === void 0 ? 0 : _b;\n\n          for (var i = 0; i < incoming.length; ++i) {\n            merged[offset + i] = incoming[i];\n          }\n        } else {\n          merged.push.apply(merged, incoming);\n        }\n      }\n\n      return merged;\n    }\n  };\n}\nexport function relayStylePagination(keyArgs) {\n  if (keyArgs === void 0) {\n    keyArgs = false;\n  }\n\n  return {\n    keyArgs: keyArgs,\n    read: function (existing, _a) {\n      var canRead = _a.canRead,\n          readField = _a.readField;\n      if (!existing) return existing;\n      var edges = [];\n      var firstEdgeCursor = \"\";\n      var lastEdgeCursor = \"\";\n      existing.edges.forEach(function (edge) {\n        if (canRead(readField(\"node\", edge))) {\n          edges.push(edge);\n\n          if (edge.cursor) {\n            firstEdgeCursor = firstEdgeCursor || edge.cursor || \"\";\n            lastEdgeCursor = edge.cursor || lastEdgeCursor;\n          }\n        }\n      });\n\n      var _b = existing.pageInfo || {},\n          startCursor = _b.startCursor,\n          endCursor = _b.endCursor;\n\n      return __assign(__assign({}, getExtras(existing)), {\n        edges: edges,\n        pageInfo: __assign(__assign({}, existing.pageInfo), {\n          startCursor: startCursor || firstEdgeCursor,\n          endCursor: endCursor || lastEdgeCursor\n        })\n      });\n    },\n    merge: function (existing, incoming, _a) {\n      var args = _a.args,\n          isReference = _a.isReference,\n          readField = _a.readField;\n\n      if (!existing) {\n        existing = makeEmptyData();\n      }\n\n      if (!incoming) {\n        return existing;\n      }\n\n      var incomingEdges = incoming.edges ? incoming.edges.map(function (edge) {\n        if (isReference(edge = __assign({}, edge))) {\n          edge.cursor = readField(\"cursor\", edge);\n        }\n\n        return edge;\n      }) : [];\n\n      if (incoming.pageInfo) {\n        var pageInfo_1 = incoming.pageInfo;\n        var startCursor = pageInfo_1.startCursor,\n            endCursor = pageInfo_1.endCursor;\n        var firstEdge = incomingEdges[0];\n        var lastEdge = incomingEdges[incomingEdges.length - 1];\n\n        if (firstEdge && startCursor) {\n          firstEdge.cursor = startCursor;\n        }\n\n        if (lastEdge && endCursor) {\n          lastEdge.cursor = endCursor;\n        }\n\n        var firstCursor = firstEdge && firstEdge.cursor;\n\n        if (firstCursor && !startCursor) {\n          incoming = mergeDeep(incoming, {\n            pageInfo: {\n              startCursor: firstCursor\n            }\n          });\n        }\n\n        var lastCursor = lastEdge && lastEdge.cursor;\n\n        if (lastCursor && !endCursor) {\n          incoming = mergeDeep(incoming, {\n            pageInfo: {\n              endCursor: lastCursor\n            }\n          });\n        }\n      }\n\n      var prefix = existing.edges;\n      var suffix = [];\n\n      if (args && args.after) {\n        var index = prefix.findIndex(function (edge) {\n          return edge.cursor === args.after;\n        });\n\n        if (index >= 0) {\n          prefix = prefix.slice(0, index + 1);\n        }\n      } else if (args && args.before) {\n        var index = prefix.findIndex(function (edge) {\n          return edge.cursor === args.before;\n        });\n        suffix = index < 0 ? prefix : prefix.slice(index);\n        prefix = [];\n      } else if (incoming.edges) {\n        prefix = [];\n      }\n\n      var edges = __spreadArray(__spreadArray(__spreadArray([], prefix, true), incomingEdges, true), suffix, true);\n\n      var pageInfo = __assign(__assign({}, incoming.pageInfo), existing.pageInfo);\n\n      if (incoming.pageInfo) {\n        var _b = incoming.pageInfo,\n            hasPreviousPage = _b.hasPreviousPage,\n            hasNextPage = _b.hasNextPage,\n            startCursor = _b.startCursor,\n            endCursor = _b.endCursor,\n            extras = __rest_1(_b, [\"hasPreviousPage\", \"hasNextPage\", \"startCursor\", \"endCursor\"]);\n\n        Object.assign(pageInfo, extras);\n\n        if (!prefix.length) {\n          if (void 0 !== hasPreviousPage) pageInfo.hasPreviousPage = hasPreviousPage;\n          if (void 0 !== startCursor) pageInfo.startCursor = startCursor;\n        }\n\n        if (!suffix.length) {\n          if (void 0 !== hasNextPage) pageInfo.hasNextPage = hasNextPage;\n          if (void 0 !== endCursor) pageInfo.endCursor = endCursor;\n        }\n      }\n\n      return __assign(__assign(__assign({}, getExtras(existing)), getExtras(incoming)), {\n        edges: edges,\n        pageInfo: pageInfo\n      });\n    }\n  };\n}\n\nvar getExtras = function (obj) {\n  return __rest(obj, notExtras);\n};\n\nvar notExtras = [\"edges\", \"pageInfo\"];\n\nfunction makeEmptyData() {\n  return {\n    edges: [],\n    pageInfo: {\n      hasPreviousPage: false,\n      hasNextPage: true,\n      startCursor: \"\",\n      endCursor: \"\"\n    }\n  };\n}","map":{"version":3,"names":["__assign","__rest","__rest_1","__spreadArray","mergeDeep","concatPagination","keyArgs","merge","existing","incoming","offsetLimitPagination","_a","args","merged","slice","_b","offset","i","length","push","apply","relayStylePagination","read","canRead","readField","edges","firstEdgeCursor","lastEdgeCursor","forEach","edge","cursor","pageInfo","startCursor","endCursor","getExtras","isReference","makeEmptyData","incomingEdges","map","pageInfo_1","firstEdge","lastEdge","firstCursor","lastCursor","prefix","suffix","after","index","findIndex","before","hasPreviousPage","hasNextPage","extras","Object","assign","obj","notExtras"],"sources":["F:/Bureau/Test_MachinesTalk/MachinesTalk/node_modules/@apollo/client/utilities/policies/pagination.js"],"sourcesContent":["import { __assign, __rest as __rest_1, __spreadArray } from \"tslib\";\nimport { __rest } from \"tslib\";\nimport { mergeDeep } from \"../common/mergeDeep.js\";\nexport function concatPagination(keyArgs) {\n    if (keyArgs === void 0) { keyArgs = false; }\n    return {\n        keyArgs: keyArgs,\n        merge: function (existing, incoming) {\n            return existing ? __spreadArray(__spreadArray([], existing, true), incoming, true) : incoming;\n        },\n    };\n}\nexport function offsetLimitPagination(keyArgs) {\n    if (keyArgs === void 0) { keyArgs = false; }\n    return {\n        keyArgs: keyArgs,\n        merge: function (existing, incoming, _a) {\n            var args = _a.args;\n            var merged = existing ? existing.slice(0) : [];\n            if (incoming) {\n                if (args) {\n                    var _b = args.offset, offset = _b === void 0 ? 0 : _b;\n                    for (var i = 0; i < incoming.length; ++i) {\n                        merged[offset + i] = incoming[i];\n                    }\n                }\n                else {\n                    merged.push.apply(merged, incoming);\n                }\n            }\n            return merged;\n        },\n    };\n}\nexport function relayStylePagination(keyArgs) {\n    if (keyArgs === void 0) { keyArgs = false; }\n    return {\n        keyArgs: keyArgs,\n        read: function (existing, _a) {\n            var canRead = _a.canRead, readField = _a.readField;\n            if (!existing)\n                return existing;\n            var edges = [];\n            var firstEdgeCursor = \"\";\n            var lastEdgeCursor = \"\";\n            existing.edges.forEach(function (edge) {\n                if (canRead(readField(\"node\", edge))) {\n                    edges.push(edge);\n                    if (edge.cursor) {\n                        firstEdgeCursor = firstEdgeCursor || edge.cursor || \"\";\n                        lastEdgeCursor = edge.cursor || lastEdgeCursor;\n                    }\n                }\n            });\n            var _b = existing.pageInfo || {}, startCursor = _b.startCursor, endCursor = _b.endCursor;\n            return __assign(__assign({}, getExtras(existing)), { edges: edges, pageInfo: __assign(__assign({}, existing.pageInfo), { startCursor: startCursor || firstEdgeCursor, endCursor: endCursor || lastEdgeCursor }) });\n        },\n        merge: function (existing, incoming, _a) {\n            var args = _a.args, isReference = _a.isReference, readField = _a.readField;\n            if (!existing) {\n                existing = makeEmptyData();\n            }\n            if (!incoming) {\n                return existing;\n            }\n            var incomingEdges = incoming.edges ? incoming.edges.map(function (edge) {\n                if (isReference(edge = __assign({}, edge))) {\n                    edge.cursor = readField(\"cursor\", edge);\n                }\n                return edge;\n            }) : [];\n            if (incoming.pageInfo) {\n                var pageInfo_1 = incoming.pageInfo;\n                var startCursor = pageInfo_1.startCursor, endCursor = pageInfo_1.endCursor;\n                var firstEdge = incomingEdges[0];\n                var lastEdge = incomingEdges[incomingEdges.length - 1];\n                if (firstEdge && startCursor) {\n                    firstEdge.cursor = startCursor;\n                }\n                if (lastEdge && endCursor) {\n                    lastEdge.cursor = endCursor;\n                }\n                var firstCursor = firstEdge && firstEdge.cursor;\n                if (firstCursor && !startCursor) {\n                    incoming = mergeDeep(incoming, {\n                        pageInfo: {\n                            startCursor: firstCursor,\n                        },\n                    });\n                }\n                var lastCursor = lastEdge && lastEdge.cursor;\n                if (lastCursor && !endCursor) {\n                    incoming = mergeDeep(incoming, {\n                        pageInfo: {\n                            endCursor: lastCursor,\n                        },\n                    });\n                }\n            }\n            var prefix = existing.edges;\n            var suffix = [];\n            if (args && args.after) {\n                var index = prefix.findIndex(function (edge) { return edge.cursor === args.after; });\n                if (index >= 0) {\n                    prefix = prefix.slice(0, index + 1);\n                }\n            }\n            else if (args && args.before) {\n                var index = prefix.findIndex(function (edge) { return edge.cursor === args.before; });\n                suffix = index < 0 ? prefix : prefix.slice(index);\n                prefix = [];\n            }\n            else if (incoming.edges) {\n                prefix = [];\n            }\n            var edges = __spreadArray(__spreadArray(__spreadArray([], prefix, true), incomingEdges, true), suffix, true);\n            var pageInfo = __assign(__assign({}, incoming.pageInfo), existing.pageInfo);\n            if (incoming.pageInfo) {\n                var _b = incoming.pageInfo, hasPreviousPage = _b.hasPreviousPage, hasNextPage = _b.hasNextPage, startCursor = _b.startCursor, endCursor = _b.endCursor, extras = __rest_1(_b, [\"hasPreviousPage\", \"hasNextPage\", \"startCursor\", \"endCursor\"]);\n                Object.assign(pageInfo, extras);\n                if (!prefix.length) {\n                    if (void 0 !== hasPreviousPage)\n                        pageInfo.hasPreviousPage = hasPreviousPage;\n                    if (void 0 !== startCursor)\n                        pageInfo.startCursor = startCursor;\n                }\n                if (!suffix.length) {\n                    if (void 0 !== hasNextPage)\n                        pageInfo.hasNextPage = hasNextPage;\n                    if (void 0 !== endCursor)\n                        pageInfo.endCursor = endCursor;\n                }\n            }\n            return __assign(__assign(__assign({}, getExtras(existing)), getExtras(incoming)), { edges: edges, pageInfo: pageInfo });\n        },\n    };\n}\nvar getExtras = function (obj) { return __rest(obj, notExtras); };\nvar notExtras = [\"edges\", \"pageInfo\"];\nfunction makeEmptyData() {\n    return {\n        edges: [],\n        pageInfo: {\n            hasPreviousPage: false,\n            hasNextPage: true,\n            startCursor: \"\",\n            endCursor: \"\",\n        },\n    };\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}