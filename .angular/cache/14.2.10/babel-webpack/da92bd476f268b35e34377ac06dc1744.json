{"ast":null,"code":"import { invariant } from \"../../utilities/globals/index.js\";\nimport { argumentsObjectFromField, DeepMerger, isNonEmptyArray, isNonNullObject } from \"../../utilities/index.js\";\nimport { hasOwn, isArray } from \"./helpers.js\";\nvar specifierInfoCache = Object.create(null);\n\nfunction lookupSpecifierInfo(spec) {\n  var cacheKey = JSON.stringify(spec);\n  return specifierInfoCache[cacheKey] || (specifierInfoCache[cacheKey] = Object.create(null));\n}\n\nexport function keyFieldsFnFromSpecifier(specifier) {\n  var info = lookupSpecifierInfo(specifier);\n  return info.keyFieldsFn || (info.keyFieldsFn = function (object, context) {\n    var extract = function (from, key) {\n      return context.readField(key, from);\n    };\n\n    var keyObject = context.keyObject = collectSpecifierPaths(specifier, function (schemaKeyPath) {\n      var extracted = extractKeyPath(context.storeObject, schemaKeyPath, extract);\n\n      if (extracted === void 0 && object !== context.storeObject && hasOwn.call(object, schemaKeyPath[0])) {\n        extracted = extractKeyPath(object, schemaKeyPath, extractKey);\n      }\n\n      __DEV__ ? invariant(extracted !== void 0, \"Missing field '\".concat(schemaKeyPath.join('.'), \"' while extracting keyFields from \").concat(JSON.stringify(object))) : invariant(extracted !== void 0, 2);\n      return extracted;\n    });\n    return \"\".concat(context.typename, \":\").concat(JSON.stringify(keyObject));\n  });\n}\nexport function keyArgsFnFromSpecifier(specifier) {\n  var info = lookupSpecifierInfo(specifier);\n  return info.keyArgsFn || (info.keyArgsFn = function (args, _a) {\n    var field = _a.field,\n        variables = _a.variables,\n        fieldName = _a.fieldName;\n    var collected = collectSpecifierPaths(specifier, function (keyPath) {\n      var firstKey = keyPath[0];\n      var firstChar = firstKey.charAt(0);\n\n      if (firstChar === \"@\") {\n        if (field && isNonEmptyArray(field.directives)) {\n          var directiveName_1 = firstKey.slice(1);\n          var d = field.directives.find(function (d) {\n            return d.name.value === directiveName_1;\n          });\n          var directiveArgs = d && argumentsObjectFromField(d, variables);\n          return directiveArgs && extractKeyPath(directiveArgs, keyPath.slice(1));\n        }\n\n        return;\n      }\n\n      if (firstChar === \"$\") {\n        var variableName = firstKey.slice(1);\n\n        if (variables && hasOwn.call(variables, variableName)) {\n          var varKeyPath = keyPath.slice(0);\n          varKeyPath[0] = variableName;\n          return extractKeyPath(variables, varKeyPath);\n        }\n\n        return;\n      }\n\n      if (args) {\n        return extractKeyPath(args, keyPath);\n      }\n    });\n    var suffix = JSON.stringify(collected);\n\n    if (args || suffix !== \"{}\") {\n      fieldName += \":\" + suffix;\n    }\n\n    return fieldName;\n  });\n}\nexport function collectSpecifierPaths(specifier, extractor) {\n  var merger = new DeepMerger();\n  return getSpecifierPaths(specifier).reduce(function (collected, path) {\n    var _a;\n\n    var toMerge = extractor(path);\n\n    if (toMerge !== void 0) {\n      for (var i = path.length - 1; i >= 0; --i) {\n        toMerge = (_a = {}, _a[path[i]] = toMerge, _a);\n      }\n\n      collected = merger.merge(collected, toMerge);\n    }\n\n    return collected;\n  }, Object.create(null));\n}\nexport function getSpecifierPaths(spec) {\n  var info = lookupSpecifierInfo(spec);\n\n  if (!info.paths) {\n    var paths_1 = info.paths = [];\n    var currentPath_1 = [];\n    spec.forEach(function (s, i) {\n      if (isArray(s)) {\n        getSpecifierPaths(s).forEach(function (p) {\n          return paths_1.push(currentPath_1.concat(p));\n        });\n        currentPath_1.length = 0;\n      } else {\n        currentPath_1.push(s);\n\n        if (!isArray(spec[i + 1])) {\n          paths_1.push(currentPath_1.slice(0));\n          currentPath_1.length = 0;\n        }\n      }\n    });\n  }\n\n  return info.paths;\n}\n\nfunction extractKey(object, key) {\n  return object[key];\n}\n\nexport function extractKeyPath(object, path, extract) {\n  extract = extract || extractKey;\n  return normalize(path.reduce(function reducer(obj, key) {\n    return isArray(obj) ? obj.map(function (child) {\n      return reducer(child, key);\n    }) : obj && extract(obj, key);\n  }, object));\n}\n\nfunction normalize(value) {\n  if (isNonNullObject(value)) {\n    if (isArray(value)) {\n      return value.map(normalize);\n    }\n\n    return collectSpecifierPaths(Object.keys(value).sort(), function (path) {\n      return extractKeyPath(value, path);\n    });\n  }\n\n  return value;\n}","map":{"version":3,"names":["invariant","argumentsObjectFromField","DeepMerger","isNonEmptyArray","isNonNullObject","hasOwn","isArray","specifierInfoCache","Object","create","lookupSpecifierInfo","spec","cacheKey","JSON","stringify","keyFieldsFnFromSpecifier","specifier","info","keyFieldsFn","object","context","extract","from","key","readField","keyObject","collectSpecifierPaths","schemaKeyPath","extracted","extractKeyPath","storeObject","call","extractKey","__DEV__","concat","join","typename","keyArgsFnFromSpecifier","keyArgsFn","args","_a","field","variables","fieldName","collected","keyPath","firstKey","firstChar","charAt","directives","directiveName_1","slice","d","find","name","value","directiveArgs","variableName","varKeyPath","suffix","extractor","merger","getSpecifierPaths","reduce","path","toMerge","i","length","merge","paths","paths_1","currentPath_1","forEach","s","p","push","normalize","reducer","obj","map","child","keys","sort"],"sources":["F:/Bureau/Test_MachinesTalk/MachinesTalk/node_modules/@apollo/client/cache/inmemory/key-extractor.js"],"sourcesContent":["import { invariant } from \"../../utilities/globals/index.js\";\nimport { argumentsObjectFromField, DeepMerger, isNonEmptyArray, isNonNullObject, } from \"../../utilities/index.js\";\nimport { hasOwn, isArray } from \"./helpers.js\";\nvar specifierInfoCache = Object.create(null);\nfunction lookupSpecifierInfo(spec) {\n    var cacheKey = JSON.stringify(spec);\n    return specifierInfoCache[cacheKey] ||\n        (specifierInfoCache[cacheKey] = Object.create(null));\n}\nexport function keyFieldsFnFromSpecifier(specifier) {\n    var info = lookupSpecifierInfo(specifier);\n    return info.keyFieldsFn || (info.keyFieldsFn = function (object, context) {\n        var extract = function (from, key) { return context.readField(key, from); };\n        var keyObject = context.keyObject = collectSpecifierPaths(specifier, function (schemaKeyPath) {\n            var extracted = extractKeyPath(context.storeObject, schemaKeyPath, extract);\n            if (extracted === void 0 &&\n                object !== context.storeObject &&\n                hasOwn.call(object, schemaKeyPath[0])) {\n                extracted = extractKeyPath(object, schemaKeyPath, extractKey);\n            }\n            __DEV__ ? invariant(extracted !== void 0, \"Missing field '\".concat(schemaKeyPath.join('.'), \"' while extracting keyFields from \").concat(JSON.stringify(object))) : invariant(extracted !== void 0, 2);\n            return extracted;\n        });\n        return \"\".concat(context.typename, \":\").concat(JSON.stringify(keyObject));\n    });\n}\nexport function keyArgsFnFromSpecifier(specifier) {\n    var info = lookupSpecifierInfo(specifier);\n    return info.keyArgsFn || (info.keyArgsFn = function (args, _a) {\n        var field = _a.field, variables = _a.variables, fieldName = _a.fieldName;\n        var collected = collectSpecifierPaths(specifier, function (keyPath) {\n            var firstKey = keyPath[0];\n            var firstChar = firstKey.charAt(0);\n            if (firstChar === \"@\") {\n                if (field && isNonEmptyArray(field.directives)) {\n                    var directiveName_1 = firstKey.slice(1);\n                    var d = field.directives.find(function (d) { return d.name.value === directiveName_1; });\n                    var directiveArgs = d && argumentsObjectFromField(d, variables);\n                    return directiveArgs && extractKeyPath(directiveArgs, keyPath.slice(1));\n                }\n                return;\n            }\n            if (firstChar === \"$\") {\n                var variableName = firstKey.slice(1);\n                if (variables && hasOwn.call(variables, variableName)) {\n                    var varKeyPath = keyPath.slice(0);\n                    varKeyPath[0] = variableName;\n                    return extractKeyPath(variables, varKeyPath);\n                }\n                return;\n            }\n            if (args) {\n                return extractKeyPath(args, keyPath);\n            }\n        });\n        var suffix = JSON.stringify(collected);\n        if (args || suffix !== \"{}\") {\n            fieldName += \":\" + suffix;\n        }\n        return fieldName;\n    });\n}\nexport function collectSpecifierPaths(specifier, extractor) {\n    var merger = new DeepMerger;\n    return getSpecifierPaths(specifier).reduce(function (collected, path) {\n        var _a;\n        var toMerge = extractor(path);\n        if (toMerge !== void 0) {\n            for (var i = path.length - 1; i >= 0; --i) {\n                toMerge = (_a = {}, _a[path[i]] = toMerge, _a);\n            }\n            collected = merger.merge(collected, toMerge);\n        }\n        return collected;\n    }, Object.create(null));\n}\nexport function getSpecifierPaths(spec) {\n    var info = lookupSpecifierInfo(spec);\n    if (!info.paths) {\n        var paths_1 = info.paths = [];\n        var currentPath_1 = [];\n        spec.forEach(function (s, i) {\n            if (isArray(s)) {\n                getSpecifierPaths(s).forEach(function (p) { return paths_1.push(currentPath_1.concat(p)); });\n                currentPath_1.length = 0;\n            }\n            else {\n                currentPath_1.push(s);\n                if (!isArray(spec[i + 1])) {\n                    paths_1.push(currentPath_1.slice(0));\n                    currentPath_1.length = 0;\n                }\n            }\n        });\n    }\n    return info.paths;\n}\nfunction extractKey(object, key) {\n    return object[key];\n}\nexport function extractKeyPath(object, path, extract) {\n    extract = extract || extractKey;\n    return normalize(path.reduce(function reducer(obj, key) {\n        return isArray(obj)\n            ? obj.map(function (child) { return reducer(child, key); })\n            : obj && extract(obj, key);\n    }, object));\n}\nfunction normalize(value) {\n    if (isNonNullObject(value)) {\n        if (isArray(value)) {\n            return value.map(normalize);\n        }\n        return collectSpecifierPaths(Object.keys(value).sort(), function (path) { return extractKeyPath(value, path); });\n    }\n    return value;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}